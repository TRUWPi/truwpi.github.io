<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRUWPi - Rule the Economy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom styles for background and font */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark purple/blue background */
            color: #e0e0e0; /* Light grey text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Hide overflow for background elements */
            position: relative;
        }

        /* Custom button styles */
        .btn-primary {
            background: linear-gradient(135deg, #8a2be2, #4b0082); /* Purple gradient */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .btn-primary:disabled {
            background: #4a4a5a; /* Darker grey for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        .btn-secondary {
            background-color: #33334d; /* Darker grey */
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary:hover {
            background-color: #444466;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .input-field {
            background-color: #33334d;
            border: 1px solid #555577;
            color: #e0e0e0;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        .input-field:focus {
            border-color: #8a2be2;
        }

        /* Main container styling for Lobby Page */
        .main-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1a1a2e; /* Match body background */
        }

        /* Header styling for Lobby Page */
        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: #22223b; /* Darker header background */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .lobby-header .left-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .lobby-header .right-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Game modes navigation for Lobby Page */
        .game-modes-nav {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            padding: 1rem 0;
            background-color: #2a2a47; /* Slightly lighter background for nav */
            box-shadow: inset 0 -2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto; /* Allow horizontal scrolling on small screens */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            white-space: nowrap; /* Prevent wrapping */
            padding-left: 2rem;
            padding-right: 2rem;
        }

        .game-modes-nav a {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: #b0b0b0;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap; /* Keep text on one line */
        }

        .game-modes-nav a:hover {
            background-color: #3e3e60;
            color: #e0e0e0;
        }

        .game-modes-nav a.active {
            background-color: #8a2be2;
            color: white;
            font-weight: bold;
        }

        /* Main content area for Lobby Page */
        .content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column; /* Stack items vertically */
            align-items: center; /* Center items horizontally */
            justify-content: center; /* Center items vertically if space allows */
            padding: 2rem;
            gap: 2rem;
            overflow-y: auto;
            position: relative; /* For absolute positioning of sidebar */
        }

        /* Party section for Lobby Page */
        .party-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center; /* Center children horizontally within party-section */
            justify-content: center; /* Center children vertically if space allows */
            height: 100%; /* Take full height of content-area */
            width: 100%; /* Take full width of content-area */
            max-width: 900px; /* Increased max width for better card layout */
            margin: 0 auto; /* Center party-section itself within content-area */
        }

        .party-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: #22223b;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            justify-content: center; /* Center content horizontally within party-controls */
            width: fit-content; /* Shrink to fit content */
            margin-left: auto; /* Auto margins for horizontal centering */
            margin-right: auto; /* Auto margins for horizontal centering */
            max-width: 90%; /* Prevent it from becoming too wide on smaller screens */
        }

        .party-code-input {
            background-color: #33334d;
            border: 1px solid #555577;
            color: #e0e0e0;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            text-align: center;
        }

        .player-cards-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            justify-content: center; /* Center cards horizontally */
            gap: 1.5rem;
            width: 100%; /* Ensure it takes full width to allow centering of cards */
        }

        .player-card {
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            padding: 1rem; /* Reduced padding */
            text-align: center;
            width: 160px; /* Smaller width for cards */
            min-height: 200px; /* Smaller consistent height */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent; /* Default border */
            transition: border-color 0.3s ease;
            position: relative; /* For crown positioning */
        }

        .player-card.active-player {
            border-color: #8a2be2; /* Highlight active player */
        }

        .player-card .player-icon {
            font-size: 3rem; /* Smaller icon size */
            margin-bottom: 0.5rem; /* Reduced margin */
            color: #e0e0e0; /* Default icon color */
        }

        .player-card h4 {
            font-size: 1.125rem; /* Equivalent to text-lg in Tailwind, smaller than text-xl */
            font-weight: bold;
            color: white;
        }

        .player-card .status-badge {
            background-color: #6ee7b7; /* Green for READY */
            color: #1a1a2e;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 0.5rem;
        }
        .player-card .status-badge.not-ready {
            background-color: #fca5a5; /* Red for not ready */
        }

        /* Leader crown icon */
        .leader-crown {
            position: absolute;
            top: 5px;
            right: 5px;
            color: gold;
            font-size: 1.5rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* Kick button styling */
        .kick-button {
            background-color: #dc2626; /* Red color */
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .kick-button:hover {
            background-color: #b91c1c;
        }
        .kick-button:disabled {
            background-color: #4a4a5a;
            cursor: not-allowed;
        }


        #lobbyPlayButton {
            background: linear-gradient(135deg, #8a2be2, #4b0082); /* Purple gradient */
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            color: white;
            font-size: 1.5rem; /* Reduced font size */
            padding: 0.75rem 3rem; /* Reduced padding */
            border-radius: 0.75rem;
            font-weight: bold;
            letter-spacing: 0.1em; /* Spacing between letters */
            margin-top: 1.5rem; /* Reduced margin top */
            cursor: pointer;
            border: none;
            outline: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
        }

        #lobbyPlayButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        #lobbyPlayButton:disabled {
            background: #4a4a5a; /* Darker grey for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Game board specific styles */
        .game-board-grid {
            display: grid;
            grid-template-columns: repeat(11, 1fr); /* 11 columns */
            grid-template-rows: repeat(11, 1fr); /* 11 rows */
            width: 850px; /* Fixed size for the board */
            height: 850px; /* Fixed size for the board */
            background-color: #33334d; /* Board background */
            overflow: hidden;
            border: 2px solid #555577;
            margin: auto; /* Center the board */
        }

        .board-cell {
            background-color: #444466; /* Changed back to original color */
            border: 1px solid #555577; /* Changed back to original color */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem; /* Kept original size */
            text-align: center;
            padding: 0.25rem; /* Kept original padding */
            position: relative; /* Crucial for player token positioning */
            min-width: 0;
            min-height: 0;
            transition: background-color 0.2s ease-in-out;
        }

        /* Hover effect for board cells: change background color */
        .board-cell:hover {
            background-color: #555580; /* Slightly lighter shade on hover */
        }

        /* Player token styling */
        .player-token {
            position: absolute; /* Position relative to .board-cell */
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease-in-out; /* Smooth transition for movement */
        }

        /* Different colors for players (you can add more) */
        .player-color-1 { background-color: #FF0000; } /* Red */
        .player-color-2 { background-color: #0000FF; } /* Blue */
        .player-color-3 { background-color: #00FF00; } /* Green */
        .player-color-4 { background-color: #FFFF00; } /* Yellow */
        .player-color-5 { background-color: #FF4500; } /* OrangeRed */

        /* Player token movement animation */
        .player-token.moving {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        /* Current player highlight */
        .player-card.current-player-highlight {
            border-color: #6ee7b7;
            box-shadow: 0 0 20px rgba(110, 231, 183, 0.5);
        }
        .player-token.current-player-highlight {
            border-color: #6ee7b7;
            box-shadow: 0 0 10px rgba(110, 231, 183, 0.8);
        }

        /* Corner cells */
        .corner-cell {
            background-color: #555577;
            font-weight: bold;
            font-size: 1rem;
        }

        /* Explicit grid positioning for each cell type */
        /* Top Row (from right to left in RTL layout) */
        .cell-top-right-corner { grid-column: 11; grid-row: 1; }
        .cell-top-1 { grid-column: 10; grid-row: 1; }
        .cell-top-2 { grid-column: 9; grid-row: 1; }
        .cell-top-3 { grid-column: 8; grid-row: 1; }
        .cell-top-4 { grid-column: 7; grid-row: 1; }
        .cell-top-5 { grid-column: 6; grid-row: 1; } /* Water */
        .cell-top-6 { grid-column: 5; grid-row: 1; }
        .cell-top-7 { grid-column: 4; grid-row: 1; }
        .cell-top-8 { grid-column: 3; grid-row: 1; }
        .cell-top-9 { grid-column: 2; grid-row: 1; }
        .cell-top-left-corner { grid-column: 1; grid-row: 1; }

        /* Left Column (from top to bottom) */
        .cell-left-1 { grid-column: 1; grid-row: 2; }
        .cell-left-2 { grid-column: 1; grid-row: 3; }
        .cell-left-3 { grid-column: 1; grid-row: 4; }
        .cell-left-4 { grid-column: 1; grid-row: 5; }
        .cell-left-5 { grid-column: 1; grid-row: 6; } /* Electricity */
        .cell-left-6 { grid-column: 1; grid-row: 7; }
        .cell-left-7 { grid-column: 1; grid-row: 8; }
        .cell-left-8 { grid-column: 1; grid-row: 9; }
        .cell-left-9 { grid-column: 1; grid-row: 10; }

        /* Bottom Row (from left to right in RTL layout) */
        .cell-bottom-left-corner { grid-column: 1; grid-row: 11; }
        .cell-bottom-1 { grid-column: 2; grid-row: 11; }
        .cell-bottom-2 { grid-column: 3; grid-row: 11; }
        .cell-bottom-3 { grid-column: 4; grid-row: 11; }
        .cell-bottom-4 { grid-column: 5; grid-row: 11; }
        .cell-bottom-5 { grid-column: 6; grid-row: 11; } /* Internet */
        .cell-bottom-6 { grid-column: 7; grid-row: 11; }
        .cell-bottom-7 { grid-column: 8; grid-row: 11; }
        .cell-bottom-8 { grid-column: 9; grid-row: 11; }
        .cell-bottom-9 { grid-column: 10; grid-row: 11; }
        .cell-bottom-right-corner { grid-column: 11; grid-row: 11; }

        /* Right Column (from bottom to top) */
        .cell-right-1 { grid-column: 11; grid-row: 10; }
        .cell-right-2 { grid-column: 11; grid-row: 9; }
        .cell-right-3 { grid-column: 11; grid-row: 8; }
        .cell-right-4 { grid-column: 11; grid-row: 7; }
        .cell-right-5 { grid-column: 11; grid-row: 6; } /* Airport */
        .cell-right-6 { grid-column: 11; grid-row: 5; }
        .cell-right-7 { grid-column: 11; grid-row: 4; }
        .cell-right-8 { grid-column: 11; grid-row: 3; }
        .cell-right-9 { grid-column: 11; grid-row: 2; }

        /* Center area for play button and random number */
        .board-center {
            grid-column: 2 / span 9; /* Spans 9 columns from 2 to 10 */
            grid-row: 2 / span 9;    /* Spans 9 rows from 2 to 10 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #22223b; /* Darker center background */
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .chat-window {
            height: 300px;
            background-color: #22223b;
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .chat-messages {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            border-bottom: 1px solid #444466;
            display: flex;
            flex-direction: column; /* Ensure messages stack vertically */
        }

        .chat-input-container {
            display: flex;
            padding: 0.5rem;
            background-color: #33334d;
        }

        .chat-input {
            flex-grow: 1;
            background-color: #444466;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            color: #e0e0e0;
            outline: none;
        }
        .chat-input::placeholder {
            color: #b0b0b0;
        }

        .chat-send-btn {
            background-color: #8a2be2;
            color: white;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .chat-send-btn:hover {
            background-color: #6a1bbd;
        }

        /* Property Details Modal Styles */
        .property-details-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #22223b;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            padding: 1.5rem;
            z-index: 30;
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            border: 2px solid #8a2be2;
        }
        .property-details-modal .close-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #e0e0e0;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .property-details-modal .close-btn:hover {
            color: #ff0000;
        }
        .property-details-modal .rent-level-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px dashed #444466;
        }
        .property-details-modal .rent-level-item:last-child {
            border-bottom: none;
        }
        .property-details-modal .rent-level-item.current-rent {
            font-weight: bold;
            color: #6ee7b7;
        }
        .property-details-modal .upgrade-controls button {
            background-color: #8a2be2;
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 1.25rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        .property-details-modal .upgrade-controls button:hover {
            background-color: #6a1bbd;
        }

        /* Money change effect in player list */
        .money-change {
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 5px;
            opacity: 0;
            transition: opacity 0.7s ease-out, transform 0.7s ease-out;
            position: relative;
            display: inline-block;
            min-width: 30px;
            text-align: right;
        }
        .money-change.plus {
            color: #6ee7b7;
        }
        .money-change.minus {
            color: #fca5a5;
        }
        .money-change.active {
            opacity: 1;
            transform: translateY(-3px);
        }

        .property-color-bar {
            width: 100%;
            height: 5px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ensure content is above the color bar but below tokens */
        .board-cell > div:not(.property-color-bar):not(.player-token) {
            position: relative; /* Ensure z-index works */
            z-index: 2;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .game-board-grid {
                width: 800px;
                height: 800px;
            }
            .content-area {
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            .party-section {
                max-width: 100%; /* Allow it to take full width on smaller screens */
            }
            .player-cards-container {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }
            .player-card {
                width: 140px; /* Adjusted for smaller screens */
                min-height: 180px; /* Adjusted for smaller screens */
                flex-shrink: 0;
            }
            .lobby-footer {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }
        }

        @media (max-width: 768px) {
            .game-board-grid {
                width: 95vw;
                height: 95vw;
                max-width: 650px;
                max-height: 650px;
                font-size: 0.6rem;
            }
            .board-cell {
                padding: 0.1rem;
            }
            .corner-cell {
                font-size: 0.8rem;
            }
            .main-game-container {
                flex-direction: column;
            }
            .left-sidebar, .right-sidebar {
                width: 100%;
                margin-top: 1rem;
            }
            .property-details-modal {
                width: 95%;
                padding: 1rem;
            }
        }

        @media (max-width: 640px) {
            .lobby-header {
                padding: 0.75rem 1rem;
            }
            .lobby-header .play-button {
                padding: 0.5rem 1rem;
                font-size: 1rem;
            }
            .content-area {
                padding: 0.75rem;
            }
            .party-controls {
                flex-direction: column;
                gap: 0.75rem;
                width: 100%;
                max-width: 350px;
            }
            .party-code-input {
                width: 100%;
            }
        }

        /* New styles for horizontal pending trades */
        .pending-trades-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping onto multiple lines if needed */
            gap: 0.5rem; /* Smaller gap between trade offers */
            overflow-x: auto; /* Enable horizontal scrolling if content overflows */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding-bottom: 0.5rem; /* Add some padding for scrollbar */
        }

        .pending-trade-item {
            background-color: #33334d;
            border-radius: 0.375rem; /* Smaller rounded corners */
            padding: 0.5rem 0.75rem; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font size */
            color: #b0b0b0;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap; /* Keep text on one line */
            flex-shrink: 0; /* Prevent items from shrinking */
            min-width: 120px; /* Minimum width for each item */
            text-align: center;
        }

        .pending-trade-item:hover {
            background-color: #444466;
            transform: translateY(-1px);
        }

        .pending-trade-item .trade-summary {
            display: block;
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 0.25rem;
        }
        .pending-trade-item .trade-details {
            display: block;
            font-size: 0.65rem; /* Even smaller font for details */
            color: #909090;
        }
    </style>
</head>
<body dir="ltr">
    <div id="lobbyPage" class="main-container">
        <header class="lobby-header">
            <div class="left-section">
                <button class="text-gray-300 hover:text-white transition-colors duration-200" id="backButton">
                    <i class="fas fa-arrow-left mr-2"></i> <span id="backButtonText">BACK</span>
                </button>
                <span class="text-xl font-bold text-white" id="lobbyTitle">LOBBY</span>
            </div>
            <div class="right-section">
                <span class="text-gray-300">
                    <i class="fas fa-users mr-1"></i> <span id="lobbyPlayerCount">0/5</span>
                </span>
                <span class="text-green-400 font-bold">
                    <i class="fas fa-coins mr-1"></i> <span id="lobbyPlayerMoney">0</span>
                </span>
                <button id="settingsBtn" class="text-gray-400 hover:text-white text-sm ml-2">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <nav class="game-modes-nav">
            <a href="#" class="active" id="unratedMode">UNRATED</a>
            <a href="#" id="competitiveMode">COMPETITIVE</a>
            <a href="#" id="customMode">CUSTOM</a>
        </nav>

        <div class="content-area">
            <div class="party-section">
                <div class="party-controls">
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" class="toggle-checkbox hidden" id="closedPartyToggle">
                        <div class="toggle-switch relative w-10 h-6 bg-gray-600 rounded-full shadow-inner">
                            <div class="toggle-dot absolute w-4 h-4 bg-white rounded-full shadow inset-y-1 left-1 transition-all duration-300 ease-in-out"></div>
                        </div>
                        <span class="text-gray-300" id="closedPartyText">CLOSED PARTY</span>
                    </label>
                    <input type="text" placeholder="PARTY CODE" class="party-code-input" id="partyCodeInput" />
                </div>

                <div class="player-cards-container" id="lobbyPlayerCardsContainer">
                    </div>

                <button id="lobbyPlayButton">
                    PLAY
                </button>
                <p id="lobbyMessage" class="text-yellow-400 mt-4 hidden">Searching for players...</p>
            </div>
        </div>
    </div>

    <div id="gamePage" class="hidden flex flex-col items-center justify-center min-h-screen p-4 md:p-8 w-full overflow-auto">
        <div class="flex flex-col lg:flex-row gap-6 justify-center items-center w-full">
            <div class="left-sidebar w-full lg:w-1/4 flex flex-col gap-4">
                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="userIdTitle">User ID</h3>
                    <p id="currentUserIdDisplay" class="text-sm text-gray-400 break-all">Local User</p>
                </div>

                <div class="chat-window shadow-md">
                    <div class="chat-messages text-sm" id="chatMessages">
                        <p class="text-gray-400" id="chatUnavailableText">Chat is local only.</p>
                        </div>
                    <div class="chat-input-container">
                        <input type="text" id="chatInput" placeholder="Say something..." class="chat-input" />
                        <button id="chatSendBtn" class="chat-send-btn"><span id="sendButtonText">Send</span></button>
                    </div>
                </div>
            </div>

            <div class="game-board-container flex-grow flex justify-center items-center relative">
                <div class="game-board-grid relative">
                    </div>
                <div id="buyPropertyModal" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-20 hidden">
                    <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-80">
                        <h3 class="text-xl font-bold mb-4" id="propertyModalTitle"></h3>
                        <p class="text-gray-300 mb-2" id="propertyModalPriceLabel">Price: <span id="propertyModalPrice" class="text-green-400 font-bold"></span></p>
                        <p class="text-gray-300 mb-4" id="playerCurrentMoneyLabel">Current Money: <span id="playerCurrentMoney" class="text-green-400 font-bold"></span></p>
                        <div class="flex justify-center gap-4">
                            <button id="buyPropertyBtn" class="btn-primary py-2 px-6 rounded-md"><span id="buyButtonText">Buy</span></button>
                            <button id="cancelBuyBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="passButtonText">Pass</span></button>
                        </div>
                    </div>
                </div>

                <div id="propertyDetailsModal" class="property-details-modal hidden">
                    <button class="close-btn" onclick="document.getElementById('propertyDetailsModal').classList.add('hidden');">&times;</button>
                    <div class="flex items-center justify-center gap-3 mb-2">
                        <div id="propertyDetailIcon"></div>
                        <h3 class="text-2xl font-bold text-white text-center" id="propertyDetailName"></h3>
                    </div>
                    <p class="text-gray-300 text-center text-lg" id="propertyDetailPriceLabel">Price: <span id="propertyDetailPrice" class="text-green-400 font-bold"></span></p>

                    <div class="bg-[#33334d] p-4 rounded-md">
                        <h4 class="text-md font-bold mb-2 text-white" id="rentLevelsTitle">Rent Levels:</h4>
                        <ul id="propertyRentLevels">
                            </ul>
                    </div>

                    <div id="upgradeSection" class="flex flex-col items-center gap-2">
                        <p class="text-gray-300 text-center text-md" id="currentUpgradeLevelDisplayLabel">Current Level: <span id="currentUpgradeLevelDisplay" class="font-bold"></span></p>
                        <div class="upgrade-controls flex gap-4">
                            <button id="downgradePropertyBtn" class="py-2 px-4 rounded-md">
                                <i class="fas fa-arrow-down"></i> <span id="downgradeRefundText"></span>
                            </button>
                            <button id="upgradePropertyBtn" class="py-2 px-4 rounded-md">
                                <i class="fas fa-arrow-up"></i> <span id="upgradeCostText"></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-sidebar w-full lg:w-1/4 flex flex-col gap-4">
                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="playersTitle">Players</h3>
                    <ul id="playersList">
                        </ul>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="tradesTitle">Trades</h3>
                    <p class="text-sm text-gray-400 mb-3" id="makeTradeText">
                        Make trades with other players to exchange properties, money, bonus cards.
                    </p>
                    <p class="text-sm text-gray-400 mb-3" id="useCreateText">
                        Use the "Create" button to initiate a new trade.
                    </p>
                    <button class="btn-primary w-full py-2 rounded-md" onclick="openTradeCreationModal(gameState.currentUser.id)"><i class="fas fa-plus mr-2"></i> <span id="createButtonText">Create</span></button>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="pendingTradesTitle">Pending Trades (<span id="pendingTradesCount">0</span>)</h3>
                    <div id="pendingTradesList" class="pending-trades-container">
                        <p class="text-gray-400" id="noPendingTradesText">No pending trades.</p>
                    </div>
                </div>

                <div class="bg-[#22223b] p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-2" id="myPropertiesTitle">My Properties (<span id="myPropertiesCount">0</span>)</h3>
                    <ul id="myPropertiesList" class="text-sm text-gray-400">
                        <li id="noPropertiesText">No properties currently.</li>
                    </ul>
                    <button class="btn-secondary w-full py-2 rounded-md mt-4" onclick="openSellPropertyModal()"><i class="fas fa-hand-holding-usd mr-2"></i> <span id="sellPropertyButtonText">Sell Property</span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="tradeCreationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-lg relative">
            <h3 class="text-xl font-bold mb-4" id="createTradeOfferTitle">Create Trade Offer</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('tradeCreationModal').classList.add('hidden');">&times;</button>
            <input type="hidden" id="tradeOfferIdToModify" value="">

            <div class="mb-4 text-left">
                <label for="tradeRecipient" class="block text-gray-300 text-sm font-bold mb-2" id="tradeWithLabel">Trade with:</label>
                <select id="tradeRecipient" class="input-field w-full"></select>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="youOfferTitle">You Offer:</h4>
                    <label for="offerMoney" class="block text-gray-300 text-xs mb-1" id="offerMoneyLabel">Money:</label>
                    <input type="number" id="offerMoney" class="input-field w-full mb-2" value="0" min="0">
                    <p class="text-gray-300 text-xs mb-1" id="yourPropertiesLabel">Your Properties:</p>
                    <div id="offeredPropertiesList" class="max-h-32 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm">
                        <p class="text-gray-400" id="noPropertiesToOfferText">No properties to offer.</p>
                    </div>
                </div>

                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="youRequestTitle">You Request:</h4>
                    <label for="requestMoney" class="block text-gray-300 text-xs mb-1" id="requestMoneyLabel">Money:</label>
                    <input type="number" id="requestMoney" class="input-field w-full mb-2" value="0" min="0">
                    <p class="text-gray-300 text-xs mb-1" id="theirPropertiesLabel">Their Properties:</p>
                    <div id="requestedPropertiesList" class="max-h-32 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm">
                        <p class="text-gray-400" id="noPropertiesToRequestText">No properties to request from this player.</p>
                    </div>
                </div>
            </div>

            <button id="sendTradeOfferBtn" class="btn-primary py-2 px-6 rounded-md w-full"><span id="sendOfferButtonText">Send Offer</span></button>
        </div>
    </div>

    <div id="incomingTradeOfferModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-md relative">
            <h3 class="text-xl font-bold mb-4" id="incomingTradeOfferTitle">Incoming Trade Offer</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('incomingTradeOfferModal').classList.add('hidden');">&times;</button>
            <p class="text-gray-300 mb-2" id="offerFromLabel">From: <span id="offerSenderName" class="font-bold"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="theyOfferTitle">They Offer:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="offerReceivedMoneyLabel">Money: $<span id="offerReceivedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="offerReceivedPropertiesLabel">Properties:</p>
                    <ul id="offerReceivedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="theyRequestTitle">They Request:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="requestSentMoneyLabel">Money: $<span id="requestSentMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="requestSentPropertiesLabel">Properties:</p>
                    <ul id="requestSentProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
            </div>

            <div class="flex justify-center gap-4">
                <button id="acceptTradeBtn" class="btn-primary py-2 px-6 rounded-md"><span id="acceptButtonText">Accept</span></button>
                <button id="declineTradeBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="declineButtonText">Decline</span></button>
                </div>
        </div>
    </div>

    <div id="tradeDetailsViewModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-md relative">
            <h3 class="text-xl font-bold mb-4" id="tradeDetailsViewTitle">Trade Offer Details</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('tradeDetailsViewModal').classList.add('hidden');">&times;</button>
            <p class="text-gray-300 mb-2" id="tradeDetailsHeader"><span id="tradeDetailsSenderName" class="font-bold"></span> <span id="tradeDetailsToText"></span> <span id="tradeDetailsRecipientName" class="font-bold"></span></p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="offeringTitle">Offering:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsOfferedMoneyLabel">Money: $<span id="tradeDetailsOfferedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsOfferedPropertiesLabel">Properties:</p>
                    <ul id="tradeDetailsOfferedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
                <div class="bg-[#33334d] p-4 rounded-md text-left">
                    <h4 class="font-bold mb-2" id="requestingTitle">Requesting:</h4>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsRequestedMoneyLabel">Money: $<span id="tradeDetailsRequestedMoney"></span></p>
                    <p class="text-gray-300 text-sm mb-1" id="tradeDetailsRequestedPropertiesLabel">Properties:</p>
                    <ul id="tradeDetailsRequestedProperties" class="list-disc list-inside text-sm text-gray-400"></ul>
                </div>
            </div>

            <div id="tradeDetailsActionButtons" class="flex justify-center gap-4">
                </div>
        </div>
    </div>

    <div id="sellPropertyModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-lg relative">
            <h3 class="text-xl font-bold mb-4" id="sellPropertiesTitle">Sell Properties</h3>
            <button class="close-btn absolute top-3 right-3 text-gray-400 hover:text-white" onclick="document.getElementById('sellPropertyModal').classList.add('hidden');">&times;</button>

            <div id="propertiesToSellList" class="max-h-64 overflow-y-auto border border-gray-600 rounded-md p-2 text-sm mb-4">
                <p class="text-gray-400" id="noPropertiesToSellText">No properties to sell.</p>
            </div>

            <button id="confirmSellPropertiesBtn" class="btn-primary py-2 px-6 rounded-md w-full"><span id="sellSelectedPropertiesButtonText">Sell Selected Properties</span></button>
        </div>
    </div>

    <div id="settingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-[#22223b] p-6 rounded-lg shadow-xl text-center w-11/12 max-w-sm relative">
            <h3 class="text-xl font-bold mb-4" id="settingsModalTitle">Settings</h3>
            <div class="mb-4 text-left">
                <label for="languageSelect" class="block text-gray-300 text-sm font-bold mb-2" id="languageLabel">Language:</label>
                <select id="languageSelect" class="input-field w-full">
                    <option value="en" id="langOptionEn">English</option>
                    <option value="ar" id="langOptionAr">العربية</option>
                </select>
            </div>
            <div class="flex justify-center gap-4">
                <button id="applySettingsBtn" class="btn-primary py-2 px-6 rounded-md"><span id="applyButtonText">Apply</span></button>
                <button id="closeSettingsBtn" class="btn-secondary py-2 px-6 rounded-md"><span id="closeButtonText">Close</span></button>
            </div>
        </div>
    </div>

    <script>
        // Debugging: Log script start
        console.log("Script execution started.");

        // Game State Object (all in-memory)
        const gameState = {
            currentUser: null, // Stores the currently logged-in user's data
            players: [], // Players in the current game (local only)
            currentPlayerIndex: 0,
            boardProperties: {}, // To store ownership of properties (local only)
            boardCellsInfo: [], // To store details of each cell including price and owner
            STARTING_MONEY: 5000,
            PASS_GO_MONEY: 500,
            pendingTradeOffers: [], // Local only
            currentActiveTradeOffer: null,
            leaderId: null, // ID of the current game leader (first player by default)
            currentLanguage: 'en', // Default language
            chatMessages: [] // Local chat messages
        };

        const MIN_PLAYERS_PER_GAME = 5;
        const MAX_PLAYERS_PER_GAME = 5; // Maximum number of players allowed in a game

        // Timer variables
        let turnTimer = null;
        let timeLeft = 0;
        const TURN_DURATION_SECONDS = 90; // 1.5 minutes

        // Translation dictionary
        const translations = {
            en: {
                back: "BACK",
                lobby: "LOBBY",
                unrated: "UNRATED",
                competitive: "COMPETITIVE",
                custom: "CUSTOM",
                closedParty: "CLOSED PARTY",
                partyCode: "PARTY CODE",
                play: "PLAY",
                money: "Money",
                ready: "Ready",
                userId: "User ID",
                saySomething: "Say something...",
                send: "Send",
                players: "Players",
                trades: "Trades",
                create: "Create",
                pendingTrades: "Pending Trades",
                myProperties: "My Properties",
                sellProperty: "Sell Property",
                noProperties: "No properties currently.",
                noPendingTrades: "No pending trades.",
                start: "Start",
                surprise: "Surprise",
                goToJail: "Go to Jail",
                vacation: "Vacation",
                water: "Water",
                electricity: "Electricity",
                internet: "Internet",
                airport: "Airport",
                timeExpired: (playerName) => `${playerName}'s turn time expired! They have been removed from the game.`,
                allPlayersRemoved: "All players have been removed. Game Over!",
                playerPassedStart: (playerName, amount) => `Player ${playerName} passed Start and collected $${amount}!`,
                playerInDebt: (playerName, balance) => `${playerName}, you are in debt! You cannot play until your balance is non-negative. Sell properties to clear your debt. Your balance: $${balance}.`,
                landedOnUnowned: (propertyName) => `Landed on unowned property: ${propertyName}.`,
                landedOnOwned: (propertyName, ownerName, rent, playerName) => `${playerName} landed on ${propertyName}, owned by ${ownerName}. Paid rent $${rent}.`,
                landedOnOwn: (propertyName) => `You landed on your own property: ${propertyName}.`,
                landedOnJail: (playerName) => `${playerName} went to Jail! (Jail logic not yet implemented)`,
                landedOnSurprise: (playerName) => `${playerName} landed on Surprise! (Surprise logic not yet implemented)`,
                landedOnVacation: (playerName) => `${playerName} is on Vacation!`,
                landedOnMisc: (content) => `You landed on: ${content}`,
                buyPropertyQuestion: (propertyName) => `Do you want to buy ${propertyName}?`,
                price: "Price",
                currentMoney: "Current Money",
                buy: "Buy",
                pass: "Pass",
                playerBought: (playerName, propertyName, price) => `${playerName} bought ${propertyName} for $${price}!`,
                playerPassed: (playerName, propertyName) => `${playerName} decided to pass on ${propertyName}.`,
                notOwnedOrExists: "You do not own this city or it does not exist!",
                mustOwnAllCities: (country) => `You must own all cities in ${country} to upgrade this property!`,
                maxLevel: "Property is already at maximum upgrade level!",
                notEnoughMoney: "You do not have enough money to upgrade this property!",
                playerUpgraded: (playerName, propertyName, level) => `${playerName} upgraded ${propertyName}! Current Level: ${level}`,
                minLevel: "Property is at base level, cannot downgrade further!",
                playerDowngraded: (playerName, propertyName, amount, level) => `${playerName} downgraded ${propertyName} and received $${amount}! Current Level: ${level}`,
                sellProperties: "Sell Properties",
                sellSelected: "Sell Selected Properties",
                noPropertiesToSell: "You have no properties to sell.",
                selectAtLeastOne: "Please select at least one property to sell.",
                playerSold: (playerName, count, amount, balance) => `${playerName} sold ${count} property(ies) and received $${amount}! Your current balance: $${balance}`,
                maxPlayersReached: "Maximum number of players reached!",
                addAtLeastOnePlayer: "Please add at least one player to start the game.",
                turnEnded: (currentPlayerName, nextPlayerName) => `Turn ended for ${currentPlayerName}. It's now ${nextPlayerName}'s turn.`,
                createTradeOffer: "Create Trade Offer",
                tradeWith: "Trade with:",
                youOffer: "You Offer:",
                money: "Money",
                yourProperties: "Your Properties:",
                noPropertiesToOffer: "No properties to offer.",
                youRequest: "You Request:",
                theirProperties: "Their Properties:",
                noPropertiesToRequest: "No properties to request from this player.",
                sendOffer: "Send Offer",
                selectRecipient: "Please select a trade recipient.",
                specifyItems: "Please specify at least one item to offer or request.",
                insufficientMoneyOffer: "You do not have enough money to offer this amount.",
                onlyOwnProperties: "You can only offer properties that you own.",
                onlyRequestOwned: "You can only request properties owned by the selected player.",
                offerSent: (recipientName) => `Trade offer sent to ${recipientName}!`,
                incomingTradeOffer: "Incoming Trade Offer",
                from: "From:",
                theyOffer: "They Offer:",
                none: "None",
                theyRequest: "They Request:",
                accept: "Accept",
                decline: "Decline",
                tradeError: "Error: Sender or recipient not found for trade.",
                senderInsufficientMoney: (senderName) => `${senderName} does not have enough money to complete this trade.`,
                recipientInsufficientMoney: (recipientName) => `${recipientName} does not have enough money to complete this trade.`,
                senderMissingProps: (senderName) => `${senderName} no longer owns some of the properties they are offering.`,
                recipientMissingProps: (recipientName) => `${recipientName} no longer owns some of the properties requested from them.`,
                tradeAccepted: (senderName, recipientName) => `Trade between ${senderName} and ${recipientName} accepted!`,
                tradeDeclined: (senderName, recipientName) => `Trade offer from ${senderName} to ${recipientName} declined.`,
                tradeCancelled: (senderName, recipientName) => `Trade offer from ${senderName} to ${recipientName} cancelled.`,
                tradeNotFound: "Trade offer not found.",
                tradeDetails: "Trade Offer Details",
                to: "To:",
                offering: "Offering:",
                requesting: "Requesting:",
                modify: "Modify",
                cancel: "Cancel",
                currentLevel: "Current Level:",
                baseRent: "Base Rent",
                level: "Level",
                max: "Max",
                min: "Min",
                makeTrade: "Make trades with other players to exchange properties, money, bonus cards.",
                useCreate: "Use the \"Create\" button to initiate a new trade.",
                aiPlayer: (id) => `AI Player ${id}`,
                settings: "Settings",
                language: "Language",
                english: "English",
                arabic: "العربية",
                apply: "Apply",
                close: "Close",
                kick: "Kick",
                confirmKick: (playerName) => `Are you sure you want to kick ${playerName} from the lobby?`,
                leader: "Leader",
                playerKicked: (playerName) => `${playerName} has been kicked from the lobby.`,
                onlyLeaderCanKick: "Only the party leader can kick players.",
                username: "Username",
                password: "Password",
                confirmPassword: "Confirm Password",
                login: "Login",
                createAccount: "Create Account",
                alreadyHaveAccount: "Already have an account? Login",
                dontHaveAccount: "Don't have an account? Create Account",
                invalidCredentials: "Invalid username or password.",
                usernameTaken: "Username is already taken.",
                passwordsMismatch: "Passwords do not match.",
                passwordTooShort: "Password must be at least 6 characters long.",
                loggedInAs: (username) => `Logged in as: ${username}`,
                searchingForPlayers: "Searching for players...",
                noOtherPlayers: "No other players online to trade with.",
                prop: "prop",
                props: "props",
                offer: "Offer",
                request: "Request",
                modifyTradeOffer: "Modify Trade Offer",
                notLoggedIn: "You are not logged in.",
                welcome: "Welcome",
                guestUser: "Guest User",
                yourUserId: "Your User ID",
                logout: "Logout",
                chatUnavailable: "Chat is local only.",
                timeLeft: "Time Left"
            },
            ar: {
                back: "العودة",
                lobby: "الردهة",
                unrated: "غير مصنف",
                competitive: "تنافسي",
                custom: "مخصص",
                closedParty: "حفلة مغلقة",
                partyCode: "رمز الحفلة",
                play: "العب",
                money: "المال",
                ready: "جاهز",
                userId: "معرف المستخدم",
                saySomething: "قل شيئًا...",
                send: "إرسال",
                players: "اللاعبون",
                trades: "الصفقات",
                create: "إنشاء",
                pendingTrades: "الصفقات المعلقة",
                myProperties: "ممتلكاتي",
                sellProperty: "بيع ممتلكات",
                noProperties: "لا توجد ممتلكات حاليًا.",
                noPendingTrades: "لا توجد صفقات معلقة.",
                start: "البداية",
                surprise: "مفاجأة",
                goToJail: "اذهب إلى السجن",
                vacation: "إجازة",
                water: "الماء",
                electricity: "الكهرباء",
                internet: "الإنترنت",
                airport: "المطار",
                timeExpired: (playerName) => `انتهى وقت دور ${playerName}! لقد تم إزالته من اللعبة.`,
                allPlayersRemoved: "تمت إزالة جميع اللاعبين. انتهت اللعبة!",
                playerPassedStart: (playerName, amount) => `مر اللاعب ${playerName} على البداية وجمع $${amount}!`,
                playerInDebt: (playerName, balance) => `أيها اللاعب ${playerName}، أنت مدين! لا يمكنك اللعب حتى يصبح رصيدك غير سالب. قم ببيع الممتلكات لتسوية دينك. رصيدك الحالي: $${balance}.`,
                landedOnUnowned: (propertyName) => `هبطت على عقار غير مملوك: ${propertyName}.`,
                landedOnOwned: (propertyName, ownerName, rent, playerName) => `هبط ${playerName} على ${propertyName}، المملوك لـ ${ownerName}. دفع إيجار $${rent}.`,
                landedOnOwn: (propertyName) => `لقد هبطت على عقارك الخاص: ${propertyName}.`,
                landedOnJail: (playerName) => `ذهب ${playerName} إلى السجن! (لم يتم تنفيذ منطق السجن بعد)`,
                landedOnSurprise: (playerName) => `هبط ${playerName} على مفاجأة! (لم يتم تنفيذ منطق المفاجأة بعد)`,
                landedOnVacation: (playerName) => ` ${playerName} في إجازة!`,
                landedOnMisc: (content) => `لقد هبطت على: ${content}`,
                buyPropertyQuestion: (propertyName) => `هل تريد شراء ${propertyName}؟`,
                price: "السعر",
                currentMoney: "المال الحالي",
                buy: "شراء",
                pass: "تخطي",
                playerBought: (playerName, propertyName, price) => `اشترى ${playerName} ${propertyName} مقابل $${price}!`,
                playerPassed: (playerName, propertyName) => `قرر ${playerName} تخطي ${propertyName}.`,
                notOwnedOrExists: "أنت لا تملك هذه المدينة أو أنها غير موجودة!",
                mustOwnAllCities: (country) => `يجب أن تمتلك جميع المدن في ${country} لترقية هذا العقار!`,
                maxLevel: "العقار بالفعل في أقصى مستوى ترقية!",
                notEnoughMoney: "ليس لديك ما يكفي من المال لترقية هذا العقار!",
                playerUpgraded: (playerName, propertyName, level) => `قام ${playerName} بترقية ${propertyName}! المستوى الحالي: ${level}`,
                minLevel: "العقار في المستوى الأساسي، لا يمكن تخفيض مستواه أكثر!",
                playerDowngraded: (playerName, propertyName, amount, level) => `قام ${playerName} بتخفيض مستوى ${propertyName} واستلم $${amount}! المستوى الحالي: ${level}`,
                sellProperties: "بيع الممتلكات",
                sellSelected: "بيع الممتلكات المحددة",
                noPropertiesToSell: "ليس لديك ممتلكات لبيعها.",
                selectAtLeastOne: "الرجاء تحديد عقار واحد على الأقل للبيع.",
                playerSold: (playerName, count, amount, balance) => `باع ${playerName} ${count} عقار(ات) واستلم $${amount}! رصيدك الحالي: $${balance}`,
                maxPlayersReached: "تم الوصول إلى الحد الأقصى لعدد اللاعبين!",
                addAtLeastOnePlayer: "الرجاء إضافة لاعب واحد على الأقل لبدء اللعبة.",
                turnEnded: (currentPlayerName, nextPlayerName) => `انتهى دور ${currentPlayerName}. الآن دور ${nextPlayerName}.`,
                createTradeOffer: "إنشاء عرض تبادل",
                tradeWith: "التبادل مع:",
                youOffer: "أنت تعرض:",
                money: "المال:",
                yourProperties: "ممتلكاتك:",
                noPropertiesToOffer: "لا توجد ممتلكات لعرضها.",
                youRequest: "أنت تطلب:",
                theirProperties: "ممتلكاتهم:",
                noPropertiesToRequest: "لا توجد ممتلكات لطلبها من هذا اللاعب.",
                sendOffer: "إرسال العرض",
                selectRecipient: "الرجاء تحديد مستلم للعرض.",
                specifyItems: "الرجاء تحديد عنصر واحد على الأقل للعرض أو الطلب.",
                insufficientMoneyOffer: "ليس لديك ما يكفي من المال لعرض هذا المبلغ.",
                onlyOwnProperties: "يمكنك فقط عرض الممتلكات التي تملكها.",
                onlyRequestOwned: "يمكنك فقط طلب الممتلكات التي يملكها اللاعب المحدد.",
                offerSent: (recipientName) => `تم إرسال عرض التبادل إلى ${recipientName}!`,
                incomingTradeOffer: "عرض تبادل وارد",
                from: "من:",
                theyOffer: "هم يعرضون:",
                none: "لا شيء",
                theyRequest: "هم يطلبون:",
                accept: "قبول",
                decline: "رفض",
                tradeError: "خطأ: لم يتم العثور على المرسل أو المستلم للصفقة.",
                senderInsufficientMoney: (senderName) => `ليس لدى ${senderName} ما يكفي من المال لإتمام هذه الصفقة.`,
                recipientInsufficientMoney: (recipientName) => `ليس لدى ${recipientName} ما يكفي من المال لإتمام هذه الصفقة.`,
                senderMissingProps: (senderName) => `لم يعد ${senderName} يملك بعض الممتلكات التي يعرضها.`,
                recipientMissingProps: (recipientName) => `لم يعد ${recipientName} يملك بعض الممتلكات المطلوبة منهم.`,
                tradeAccepted: (senderName, recipientName) => `تم قبول الصفقة بين ${senderName} و ${recipientName}!`,
                tradeDeclined: (senderName, recipientName) => `تم رفض عرض التبادل من ${senderName} إلى ${recipientName}.`,
                tradeCancelled: (senderName, recipientName) => `تم إلغاء عرض التبادل من ${senderName} إلى ${recipientName}.`,
                tradeNotFound: "لم يتم العثور على عرض التبادل.",
                tradeDetails: "تفاصيل عرض التبادل",
                to: "إلى:",
                offering: "يعرض:",
                requesting: "يطلب:",
                modify: "تعديل",
                cancel: "إلغاء",
                currentLevel: "المستوى الحالي:",
                baseRent: "الإيجار الأساسي",
                level: "المستوى",
                max: "الحد الأقصى",
                min: "الحد الأدنى",
                makeTrade: "قم بإجراء صفقات مع لاعبين آخرين لتبادل الممتلكات والمال وبطاقات المكافآت.",
                useCreate: "استخدم زر \"إنشاء\" لبدء صفقة جديدة.",
                aiPlayer: (id) => `اللاعب الآلي ${id}`,
                settings: "الإعدادات",
                language: "اللغة",
                english: "الإنجليزية",
                arabic: "العربية",
                apply: "تطبيق",
                close: "إغلاق",
                kick: "طرد",
                confirmKick: (playerName) => `هل أنت متأكد أنك تريد طرد ${playerName} من الردهة؟`,
                leader: "القائد",
                playerKicked: (playerName) => `${playerName} تم طرده من الردهة.`,
                onlyLeaderCanKick: "فقط قائد الحفلة يمكنه طرد اللاعبين.",
                username: "اسم المستخدم",
                password: "كلمة المرور",
                confirmPassword: "تأكيد كلمة المرور",
                login: "تسجيل الدخول",
                createAccount: "إنشاء حساب",
                alreadyHaveAccount: "بالفعل لديك حساب؟ تسجيل الدخول",
                dontHaveAccount: "ليس لديك حساب؟ إنشاء حساب",
                invalidCredentials: "اسم المستخدم أو كلمة المرور غير صحيحة.",
                usernameTaken: "اسم المستخدم هذا موجود بالفعل.",
                passwordsMismatch: "كلمات المرور غير متطابقة.",
                passwordTooShort: "يجب أن تتكون كلمة المرور من 6 أحرف على الأقل.",
                loggedInAs: (username) => `تم تسجيل الدخول باسم: ${username}`,
                searchingForPlayers: "جاري البحث عن لاعبين...",
                noOtherPlayers: "لا يوجد لاعبون آخرون متصلون للمقايضة معهم.",
                prop: "عقار",
                props: "عقارات",
                offer: "عرض",
                request: "طلب",
                modifyTradeOffer: "تعديل عرض التبادل",
                notLoggedIn: "أنت غير مسجل الدخول.",
                welcome: "مرحباً",
                guestUser: "مستخدم ضيف",
                yourUserId: "معرف المستخدم الخاص بك",
                logout: "تسجيل الخروج",
                chatUnavailable: "الدردشة محلية فقط.",
                timeLeft: "الوقت المتبقي"
            }
        };

        function getTranslation(key, ...args) {
            const translation = translations[gameState.currentLanguage][key];
            if (typeof translation === 'function') {
                return translation(...args);
            }
            return translation || key; // Fallback to key if not found
        }

        function updateAllTextContent() {
            // Update header
            const backButtonText = document.getElementById('backButtonText');
            if (backButtonText) backButtonText.textContent = getTranslation('back');

            const lobbyTitle = document.getElementById('lobbyTitle');
            if (lobbyTitle) lobbyTitle.textContent = getTranslation('lobby');

            // Update game modes navigation
            const unratedMode = document.getElementById('unratedMode');
            if (unratedMode) unratedMode.textContent = getTranslation('unrated');

            const competitiveMode = document.getElementById('competitiveMode');
            if (competitiveMode) competitiveMode.textContent = getTranslation('competitive');

            const customMode = document.getElementById('customMode');
            if (customMode) customMode.textContent = getTranslation('custom');

            // Update party section (simplified for local game)
            const closedPartyText = document.getElementById('closedPartyText');
            if (closedPartyText) closedPartyText.textContent = getTranslation('closedParty');

            const partyCodeInput = document.getElementById('partyCodeInput');
            if (partyCodeInput) partyCodeInput.placeholder = getTranslation('partyCode');

            // Update lobby player cards (re-render)
            updateLobbyPlayerCards();

            const lobbyPlayButton = document.getElementById('lobbyPlayButton');
            if (lobbyPlayButton) lobbyPlayButton.textContent = getTranslation('play');

            const lobbyMessage = document.getElementById('lobbyMessage');
            if (lobbyMessage) lobbyMessage.textContent = getTranslation('searchingForPlayers');


            // Update game page elements
            const userIdTitle = document.getElementById('userIdTitle');
            if (userIdTitle) userIdTitle.textContent = getTranslation('userId');

            const currentUserIdDisplay = document.getElementById('currentUserIdDisplay');
            if (currentUserIdDisplay) currentUserIdDisplay.textContent = gameState.currentUser ? gameState.currentUser.name : getTranslation('notLoggedIn'); // Display username

            const chatUnavailableText = document.getElementById('chatUnavailableText');
            if (chatUnavailableText) chatUnavailableText.textContent = getTranslation('chatUnavailable');

            const chatInput = document.getElementById('chatInput');
            if (chatInput) chatInput.placeholder = getTranslation('saySomething');

            const sendButtonText = document.getElementById('sendButtonText');
            if (sendButtonText) sendButtonText.textContent = getTranslation('send');

            const playersTitle = document.getElementById('playersTitle');
            if (playersTitle) playersTitle.textContent = getTranslation('players');

            const tradesTitle = document.getElementById('tradesTitle');
            if (tradesTitle) tradesTitle.textContent = getTranslation('trades');

            const makeTradeText = document.getElementById('makeTradeText');
            if (makeTradeText) makeTradeText.textContent = getTranslation('makeTrade');

            const useCreateText = document.getElementById('useCreateText');
            if (useCreateText) useCreateText.textContent = getTranslation('useCreate');

            const createButtonText = document.getElementById('createButtonText');
            if (createButtonText) createButtonText.textContent = getTranslation('create');

            const pendingTradesTitle = document.getElementById('pendingTradesTitle');
            if (pendingTradesTitle) pendingTradesTitle.innerHTML = `${getTranslation('pendingTrades')} (<span id="pendingTradesCount">${gameState.pendingTradeOffers.length}</span>)`;

            const noPendingTradesText = document.getElementById('noPendingTradesText');
            if (noPendingTradesText) noPendingTradesText.textContent = getTranslation('noPendingTrades');

            const myPropertiesTitle = document.getElementById('myPropertiesTitle');
            if (myPropertiesTitle) myPropertiesTitle.innerHTML = `${getTranslation('myProperties')} (<span id="myPropertiesCount">${Object.values(gameState.boardProperties).filter(prop => prop.ownerId === gameState.currentUser?.id).length}</span>)`;

            const noPropertiesText = document.getElementById('noPropertiesText');
            if (noPropertiesText) noPropertiesText.textContent = getTranslation('noProperties');

            const sellPropertyButtonText = document.getElementById('sellPropertyButtonText');
            if (sellPropertyButtonText) sellPropertyButtonText.textContent = getTranslation('sellProperty');

            // Modals
            const propertyModalTitle = document.getElementById('propertyModalTitle');
            if (propertyModalTitle) propertyModalTitle.textContent = getTranslation('buyPropertyQuestion', ''); // Title is dynamic, only update "Do you want to buy" part

            const propertyModalPriceLabel = document.getElementById('propertyModalPriceLabel');
            if (propertyModalPriceLabel && propertyModalPriceLabel.childNodes[0]) propertyModalPriceLabel.childNodes[0].nodeValue = getTranslation('price') + ": ";

            const playerCurrentMoneyLabel = document.getElementById('playerCurrentMoneyLabel');
            if (playerCurrentMoneyLabel && playerCurrentMoneyLabel.childNodes[0]) playerCurrentMoneyLabel.childNodes[0].nodeValue = getTranslation('currentMoney') + ": ";

            const buyButtonText = document.getElementById('buyButtonText');
            if (buyButtonText) buyButtonText.textContent = getTranslation('buy');

            const passButtonText = document.getElementById('passButtonText');
            if (passButtonText) passButtonText.textContent = getTranslation('pass');

            const rentLevelsTitle = document.getElementById('rentLevelsTitle');
            if (rentLevelsTitle) rentLevelsTitle.textContent = getTranslation('rentLevels');

            const currentUpgradeLevelDisplayLabel = document.getElementById('currentUpgradeLevelDisplayLabel');
            if (currentUpgradeLevelDisplayLabel && currentUpgradeLevelDisplayLabel.childNodes[0]) currentUpgradeLevelDisplayLabel.childNodes[0].nodeValue = getTranslation('currentLevel') + ": ";

            const downgradeRefundText = document.getElementById('downgradeRefundText');
            if (downgradeRefundText) downgradeRefundText.textContent = getTranslation('min'); // Default text

            const upgradeCostText = document.getElementById('upgradeCostText');
            if (upgradeCostText) upgradeCostText.textContent = getTranslation('max'); // Default text

            const createTradeOfferTitle = document.getElementById('createTradeOfferTitle');
            if (createTradeOfferTitle) createTradeOfferTitle.textContent = getTranslation('createTradeOffer');

            const tradeWithLabel = document.getElementById('tradeWithLabel');
            if (tradeWithLabel) tradeWithLabel.textContent = getTranslation('tradeWith') + ":";

            const youOfferTitle = document.getElementById('youOfferTitle');
            if (youOfferTitle) youOfferTitle.textContent = getTranslation('youOffer');

            const offerMoneyLabel = document.getElementById('offerMoneyLabel');
            if (offerMoneyLabel) offerMoneyLabel.textContent = getTranslation('money') + ":";

            const yourPropertiesLabel = document.getElementById('yourPropertiesLabel');
            if (yourPropertiesLabel) yourPropertiesLabel.textContent = getTranslation('yourProperties');

            const noPropertiesToOfferText = document.getElementById('noPropertiesToOfferText');
            if (noPropertiesToOfferText) noPropertiesToOfferText.textContent = getTranslation('noPropertiesToOffer');

            const youRequestTitle = document.getElementById('youRequestTitle');
            if (youRequestTitle) youRequestTitle.textContent = getTranslation('youRequest');

            const requestMoneyLabel = document.getElementById('requestMoneyLabel');
            if (requestMoneyLabel) requestMoneyLabel.textContent = getTranslation('money') + ":";

            const theirPropertiesLabel = document.getElementById('theirPropertiesLabel');
            if (theirPropertiesLabel) theirPropertiesLabel.textContent = getTranslation('theirProperties');

            const noPropertiesToRequestText = document.getElementById('noPropertiesToRequestText');
            if (noPropertiesToRequestText) noPropertiesToRequestText.textContent = getTranslation('noPropertiesToRequest');

            const sendOfferButtonText = document.getElementById('sendOfferButtonText');
            if (sendOfferButtonText) sendOfferButtonText.textContent = getTranslation('sendOffer');

            const incomingTradeOfferTitle = document.getElementById('incomingTradeOfferTitle');
            if (incomingTradeOfferTitle) incomingTradeOfferTitle.textContent = getTranslation('incomingTradeOffer');

            const offerFromLabel = document.getElementById('offerFromLabel');
            if (offerFromLabel && offerFromLabel.childNodes[0]) offerFromLabel.childNodes[0].nodeValue = getTranslation('from') + ": ";

            const theyOfferTitle = document.getElementById('theyOfferTitle');
            if (theyOfferTitle) theyOfferTitle.textContent = getTranslation('theyOffer');

            const offerReceivedMoneyLabel = document.getElementById('offerReceivedMoneyLabel');
            if (offerReceivedMoneyLabel && offerReceivedMoneyLabel.childNodes[0]) offerReceivedMoneyLabel.childNodes[0].nodeValue = getTranslation('money') + ": $";

            const offerReceivedPropertiesLabel = document.getElementById('offerReceivedPropertiesLabel');
            if (offerReceivedPropertiesLabel) offerReceivedPropertiesLabel.textContent = getTranslation('properties') + ":";

            const theyRequestTitle = document.getElementById('theyRequestTitle');
            if (theyRequestTitle) theyRequestTitle.textContent = getTranslation('theyRequest');

            const requestSentMoneyLabel = document.getElementById('requestSentMoneyLabel');
            if (requestSentMoneyLabel && requestSentMoneyLabel.childNodes[0]) requestSentMoneyLabel.childNodes[0].nodeValue = getTranslation('money') + ": $";

            const requestSentPropertiesLabel = document.getElementById('requestSentPropertiesLabel');
            if (requestSentPropertiesLabel) requestSentPropertiesLabel.textContent = getTranslation('properties') + ":";

            const acceptButtonText = document.getElementById('acceptButtonText');
            if (acceptButtonText) acceptButtonText.textContent = getTranslation('accept');

            const declineButtonText = document.getElementById('declineButtonText');
            if (declineButtonText) declineButtonText.textContent = getTranslation('decline');

            const tradeDetailsViewTitle = document.getElementById('tradeDetailsViewTitle');
            if (tradeDetailsViewTitle) tradeDetailsViewTitle.textContent = getTranslation('tradeDetails');

            const tradeDetailsHeader = document.getElementById('tradeDetailsHeader');
            if (tradeDetailsHeader && tradeDetailsHeader.childNodes[0]) tradeDetailsHeader.childNodes[0].nodeValue = getTranslation('from') + ": ";

            const tradeDetailsToText = document.getElementById('tradeDetailsToText');
            if (tradeDetailsToText) tradeDetailsToText.textContent = getTranslation('to');

            const offeringTitle = document.getElementById('offeringTitle');
            if (offeringTitle) offeringTitle.textContent = getTranslation('offering');

            const tradeDetailsOfferedMoneyLabel = document.getElementById('tradeDetailsOfferedMoneyLabel');
            if (tradeDetailsOfferedMoneyLabel && tradeDetailsOfferedMoneyLabel.childNodes[0]) tradeDetailsOfferedMoneyLabel.childNodes[0].nodeValue = getTranslation('money') + ": $";

            const tradeDetailsOfferedPropertiesLabel = document.getElementById('tradeDetailsOfferedPropertiesLabel');
            if (tradeDetailsOfferedPropertiesLabel) tradeDetailsOfferedPropertiesLabel.textContent = getTranslation('properties') + ":";

            const requestingTitle = document.getElementById('requestingTitle');
            if (requestingTitle) requestingTitle.textContent = getTranslation('requesting');

            const tradeDetailsRequestedMoneyLabel = document.getElementById('tradeDetailsRequestedMoneyLabel');
            if (tradeDetailsRequestedMoneyLabel && tradeDetailsRequestedMoneyLabel.childNodes[0]) tradeDetailsRequestedMoneyLabel.childNodes[0].nodeValue = getTranslation('money') + ": $";

            const tradeDetailsRequestedPropertiesLabel = document.getElementById('tradeDetailsRequestedPropertiesLabel');
            if (tradeDetailsRequestedPropertiesLabel) tradeDetailsRequestedPropertiesLabel.textContent = getTranslation('properties') + ":";

            const sellPropertiesTitle = document.getElementById('sellPropertiesTitle');
            if (sellPropertiesTitle) sellPropertiesTitle.textContent = getTranslation('sellProperties');

            const noPropertiesToSellText = document.getElementById('noPropertiesToSellText');
            if (noPropertiesToSellText) noPropertiesToSellText.textContent = getTranslation('noPropertiesToSell');

            const sellSelectedPropertiesButtonText = document.getElementById('sellSelectedPropertiesButtonText');
            if (sellSelectedPropertiesButtonText) sellSelectedPropertiesButtonText.textContent = getTranslation('sellSelected');

            const settingsModalTitle = document.getElementById('settingsModalTitle');
            if (settingsModalTitle) settingsModalTitle.textContent = getTranslation('settings');

            const languageLabel = document.getElementById('languageLabel');
            if (languageLabel) languageLabel.textContent = getTranslation('language') + ":";

            const langOptionEn = document.getElementById('langOptionEn');
            if (langOptionEn) langOptionEn.textContent = getTranslation('english');

            const langOptionAr = document.getElementById('langOptionAr');
            if (langOptionAr) langOptionAr.textContent = getTranslation('arabic');

            const applyButtonText = document.getElementById('applyButtonText');
            if (applyButtonText) applyButtonText.textContent = getTranslation('apply');

            const closeButtonText = document.getElementById('closeButtonText');
            if (closeButtonText) closeButtonText.textContent = getTranslation('close');


            // Update board cell display to reflect new language for city names
            if (gameState.boardCellsInfo.length > 0) {
                gameState.boardCellsInfo.forEach(cell => {
                    const cellElement = document.querySelector(`.${cell.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, cell);
                    }
                });
            }

            // Removed document.body.dir change based on language
            // document.body.dir = (gameState.currentLanguage === 'ar') ? 'rtl' : 'ltr';
        }

        // Custom alert function (replaces window.alert)
        function alert(message) {
            const existingAlert = document.getElementById('custom-alert');
            if (existingAlert) {
                existingAlert.remove();
            }

            const alertDiv = document.createElement('div');
            alertDiv.id = 'custom-alert';
            // Increased vertical padding (py-10) and reduced horizontal padding (px-3)
            alertDiv.className = 'fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-800 text-white py-10 px-3 rounded-lg shadow-lg z-50 flex flex-col items-center';
            alertDiv.style.minWidth = '250px';

            const messageP = document.createElement('p');
            messageP.textContent = message;
            // Increased text size for alert message
            messageP.className = 'text-xl mb-4 text-center';
            alertDiv.appendChild(messageP);

            const closeButton = document.createElement('button');
            closeButton.textContent = 'OK';
            closeButton.className = 'bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500';
            closeButton.onclick = () => alertDiv.remove();
            alertDiv.appendChild(closeButton);

            document.body.appendChild(alertDiv);
        }

        // Function to show money gain/loss effect directly in the player list
        function showMoneyEffect(playerId, amount, type) {
            const moneyChangeSpan = document.getElementById(`player-money-change-${playerId}`);
            if (!moneyChangeSpan) return;

            moneyChangeSpan.textContent = `${type === 'gain' ? '+' : '-'}${amount}`;
            moneyChangeSpan.classList.remove('plus', 'minus'); // Clear previous classes
            moneyChangeSpan.classList.add(type); // Add 'gain' or 'loss'
            moneyChangeSpan.classList.add('active'); // Activate animation

            // Set a timeout to remove the 'active' class (trigger fade out)
            setTimeout(() => {
                moneyChangeSpan.classList.remove('active');
                // Clear text content after the transition finishes for cleanliness
                setTimeout(() => {
                    moneyChangeSpan.textContent = '';
                }, 700); // Match the transition duration in CSS
            }, 1500); // Show for 1.5 seconds before starting to fade
        }

        // Function to get the URL for a country flag image (still used for property details modal icon)
        function getCountryFlagImage(country) {
            const countryCodes = {
                "France": "fr", "فرنسا": "fr",
                "Germany": "de", "ألمانيا": "de",
                "USA": "us", "الولايات المتحدة": "us",
                "Canada": "ca", "كندا": "ca",
                "Brazil": "br", "البرازيل": "br",
                "Argentina": "ar", "الأرجنتين": "ar",
                "Egypt": "eg", "مصر": "eg",
                "Nigeria": "ng", "نيجيريا": "ng",
                "Japan": "jp", "اليابان": "jp",
                "India": "in", "الهند": "in",
                "Mexico": "mx", "المكسيك": "mx",
                "United Kingdom": "gb", "المملكة المتحدة": "gb",
                "Australia": "au", "أستراليا": "au",
                "UAE": "ae", "الإمارات": "ae",
                "Singapore": "sg", "سنغافورة": "sg",
                "South Africa": "za", "جنوب أفريقيا": "za"
            };
            const code = countryCodes[country] ? countryCodes[country].toLowerCase() : 'xx'; // 'xx' for unknown
            const imageUrl = `https://flagcdn.com/w40/${code}.png`;
            // Fallback to a placeholder image if the actual flag image fails to load
            const fallbackImageUrl = `https://placehold.co/40x30/cccccc/000000?text=${encodeURIComponent(country.substring(0,2).toUpperCase())}`;
            return `<img src="${imageUrl}" alt="${country} Flag" class="w-6 h-auto" onerror="this.onerror=null;this.src='${fallbackImageUrl}';">`;
        }

        // Function to get the emoji for a company property
        function getCompanyEmoji(companyName) {
            const companyEmojis = {
                "Water": "💧", "الماء": "💧",
                "Electricity": "⚡", "الكهرباء": "⚡",
                "Internet": "🌐", "الإنترنت": "🌐",
                "Airport": "✈️", "المطار": "✈️"
            };
            return companyEmojis[companyName] || ''; // Return emoji or empty string if not found
        }

        // Define the board path in sequential order (used for player movement and cell ID mapping)
        const boardPath = [
            "cell-top-right-corner", // 0: Start
            "cell-top-1", // 1
            "cell-top-2", // 2
            "cell-top-3", // 3
            "cell-top-4", // 4
            "cell-top-5", // 5: Water
            "cell-top-6", // 6
            "cell-top-7", // 7
            "cell-top-8", // 8
            "cell-top-9", // 9
            "cell-top-left-corner", // 10: Surprise
            "cell-left-1", // 11
            "cell-left-2", // 12
            "cell-left-3", // 13
            "cell-left-4", // 14
            "cell-left-5", // 15: Electricity
            "cell-left-6", // 16
            "cell-left-7", // 17
            "cell-left-8", // 18
            "cell-left-9", // 19
            "cell-bottom-left-corner", // 20: Go to Jail
            "cell-bottom-1", // 21
            "cell-bottom-2", // 22
            "cell-bottom-3", // 23
            "cell-bottom-4", // 24
            "cell-bottom-5", // 25: Internet
            "cell-bottom-6", // 26
            "cell-bottom-7", // 27
            "cell-bottom-8", // 28
            "cell-bottom-9", // 29
            "cell-bottom-right-corner", // 30: Vacation
            "cell-right-1", // 31
            "cell-right-2", // 32
            "cell-right-3", // 33
            "cell-right-4", // 34
            "cell-right-5", // 35: Airport
            "cell-right-6", // 36
            "cell-right-7", // 37
            "cell-right-8", // 38
            "cell-right-9"  // 39
        ];

        // Helper to round to the nearest multiple of 5
        function roundToNearestFive(num) {
            return Math.round(num / 5) * 5;
        }

        // Define base prices for countries (richer countries have higher base prices)
        // Prices are now fixed, multiples of 5, and within 100-500 range
        const countryBasePrices = {
            "USA": 480, "الولايات المتحدة": 480,
            "Germany": 440, "ألمانيا": 440,
            "Japan": 460, "اليابان": 460,
            "France": 420, "فرنسا": 420,
            "Canada": 400, "كندا": 400,
            "Brazil": 205, "البرازيل": 205,
            "Argentina": 185, "الأرجنتين": 185,
            "Egypt": 165, "مصر": 165,
            "India": 125, "الهند": 125,
            "Mexico": 225, "المكسيك": 225
        };

        // Function to generate rent levels based on base price
        function generateRentLevels(basePrice) {
            const rents = [];
            rents[0] = roundToNearestFive(basePrice * 0.10); // Base Rent
            rents[1] = roundToNearestFive(basePrice * 0.25); // Level 1
            rents[2] = roundToNearestFive(basePrice * 0.50); // Level 2
            rents[3] = roundToNearestFive(basePrice * 0.75); // Level 3
            rents[4] = roundToNearestFive(basePrice * 1.00); // Level 4
            return rents;
        }

        /**
         * Updates the visual display of a single board cell based on its current state.
         * This is called after a property is purchased, upgraded, or downgraded.
         * @param {HTMLElement} cellElement - The DOM element of the cell to update.
         * @param {object} cellInfo - The cell's information object from gameState.boardCellsInfo.
         */
        function updateBoardCellDisplay(cellElement, cellInfo) {
            if (!cellElement) {
                console.error("Cell element is null or undefined.");
                return;
            }
            if (!cellInfo) {
                console.error("Cell info is null or undefined for cell element:", cellElement);
                return;
            }

            // Preserve player tokens and existing color bar
            const playerTokens = Array.from(cellElement.querySelectorAll('.player-token'));
            const existingColorBar = cellElement.querySelector('.property-color-bar');

            cellElement.innerHTML = ''; // Clear everything else

            // Re-append the color bar or create a new one
            let colorBar;
            if (existingColorBar) {
                colorBar = existingColorBar;
            } else {
                colorBar = document.createElement('div');
                colorBar.classList.add('w-full', 'h-2', 'absolute', 'top-0', 'left-0', 'property-color-bar');
            }

            const ownerPlayer = cellInfo.owner !== null ? gameState.players.find(p => p.id === cellInfo.owner) : null;

            // Logic for color bar visibility and color
            if (cellInfo.type === 'city' || cellInfo.type === 'company') {
                colorBar.classList.remove('hidden'); // Always show for city/company
                colorBar.style.backgroundColor = ownerPlayer ? ownerPlayer.color : '#FFFFFF'; // White if unowned, player color if owned
            } else {
                colorBar.classList.add('hidden'); // Hide for other cell types (corners)
            }
            cellElement.appendChild(colorBar);

            // Create a container for the main content to control its z-index and layout
            const contentContainer = document.createElement('div');
            contentContainer.className = 'flex flex-col items-center justify-center h-full w-full relative z-2'; // z-index 2 for content

            // Get the display name for the current language
            let displayName = cellInfo.content[gameState.currentLanguage] || cellInfo.content['en'] || cellInfo.content;
            let countryName = cellInfo.country ? (cellInfo.country[gameState.currentLanguage] || cellInfo.country['en'] || cellInfo.country) : '';


            if (cellInfo.type === 'city') {
                // City Name (under the color bar)
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-xs font-bold leading-tight mt-1'; // Added mt-1 to move down slightly
                nameDiv.textContent = displayName;
                contentContainer.appendChild(nameDiv);

                // Country Flag
                const countryFlagDiv = document.createElement('div');
                countryFlagDiv.className = 'flex-shrink-0 mb-1'; // Added mb-1 to move up slightly
                countryFlagDiv.innerHTML = getCountryFlagImage(countryName);
                contentContainer.appendChild(countryFlagDiv);

                // Price
                const priceDiv = document.createElement('div');
                priceDiv.className = 'text-xs font-bold text-green-400 leading-tight';
                priceDiv.textContent = `$${cellInfo.price}`;
                contentContainer.appendChild(priceDiv);

                // Level
                const levelDiv = document.createElement('div');
                levelDiv.className = 'text-xs text-gray-400 leading-tight';
                levelDiv.textContent = `${getTranslation('level')}: ${cellInfo.currentUpgradeLevel}`; // Abbreviated "Level"
                contentContainer.appendChild(levelDiv);

            } else if (cellInfo.type === 'company') {
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-xs font-bold leading-tight';
                nameDiv.textContent = displayName;
                contentContainer.appendChild(nameDiv);

                const priceDiv = document.createElement('div');
                priceDiv.className = 'text-xs font-bold text-green-400 leading-tight';
                priceDiv.textContent = `$${cellInfo.price}`;
                contentContainer.appendChild(priceDiv);

                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'text-lg';
                emojiDiv.innerHTML = getCompanyEmoji(displayName);
                contentContainer.appendChild(emojiDiv);

            } else if (cellInfo.type === 'corner') {
                const emojiDiv = document.createElement('div');
                emojiDiv.className = 'text-3xl';
                emojiDiv.innerHTML = cellInfo.emoji;
                contentContainer.appendChild(emojiDiv);
            }

            // Append the content container to the cell
            cellElement.appendChild(contentContainer);

            // Re-append player tokens
            playerTokens.forEach(token => cellElement.appendChild(token));

            console.log(`Updated cell ${cellInfo.id}. InnerHTML:`, cellElement.innerHTML); // Debug log
        }


        // Function to populate the board with cities and special cells dynamically
        function populateBoard() {
            // Assign the static board layout for "World 1"
            // This ensures the board is always the same and cities of the same country are adjacent.
            gameState.boardCellsInfo = [
                // Index 0: Start
                { id: "cell-top-right-corner", type: "corner", content: { en: "Start", ar: "البداية" }, emoji: "➡️", boardIndex: 0, owner: null },

                // Top Row Cities (USA)
                { id: "cell-top-1", type: "city", content: { en: "New York", ar: "نيويورك" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-2", type: "city", content: { en: "Los Angeles", ar: "لوس أنجلوس" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-3", type: "city", content: { en: "Chicago", ar: "شيكاغو" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },
                { id: "cell-top-4", type: "city", content: { en: "Houston", ar: "هيوستن" }, country: { en: "USA", ar: "الولايات المتحدة" }, price: countryBasePrices["USA"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["USA"]), owner: null },

                // Index 5: Water Company
                { id: "cell-top-5", type: "company", content: { en: "Water", ar: "الماء" }, price: 150, emoji: "💧", rentLevels: [15], boardIndex: 5, owner: null },

                // Top Row Cities (Germany)
                { id: "cell-top-6", type: "city", content: { en: "Berlin", ar: "برلين" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-7", type: "city", content: { en: "Munich", ar: "ميونخ" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-8", type: "city", content: { en: "Hamburg", ar: "هامبورغ" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },
                { id: "cell-top-9", type: "city", content: { en: "Frankfurt", ar: "فرانكفورت" }, country: { en: "Germany", ar: "ألمانيا" }, price: countryBasePrices["Germany"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Germany"]), owner: null },

                // Index 10: Surprise
                { id: "cell-top-left-corner", type: "corner", content: { en: "Surprise", ar: "مفاجأة" }, emoji: "📦", boardIndex: 10, owner: null },

                // Left Column Cities (Japan)
                { id: "cell-left-1", type: "city", content: { en: "Tokyo", ar: "طوكيو" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-2", type: "city", content: { en: "Osaka", ar: "أوساكا" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-3", type: "city", content: { en: "Kyoto", ar: "كيوتو" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },
                { id: "cell-left-4", type: "city", content: { en: "Sapporo", ar: "سابورو" }, country: { en: "Japan", ar: "اليابان" }, price: countryBasePrices["Japan"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Japan"]), owner: null },

                // Index 15: Electricity Company
                { id: "cell-left-5", type: "company", content: { en: "Electricity", ar: "الكهرباء" }, price: 150, emoji: "⚡", rentLevels: [15], boardIndex: 15, owner: null },

                // Left Column Cities (France)
                { id: "cell-left-6", type: "city", content: { en: "Paris", ar: "باريس" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-7", type: "city", content: { en: "Marseille", ar: "مرسيليا" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-8", type: "city", content: { en: "Lyon", ar: "ليون" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },
                { id: "cell-left-9", type: "city", content: { en: "Nice", ar: "نيس" }, country: { en: "France", ar: "فرنسا" }, price: countryBasePrices["France"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["France"]), owner: null },

                // Index 20: Go to Jail
                { id: "cell-bottom-left-corner", type: "corner", content: { en: "Go to Jail", ar: "اذهب إلى السجن" }, emoji: "🚓", boardIndex: 20, owner: null },

                // Bottom Row Cities (Canada, Brazil, Argentina)
                { id: "cell-bottom-1", type: "city", content: { en: "Toronto", ar: "تورونتو" }, country: { en: "Canada", ar: "كندا" }, price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-2", type: "city", content: { en: "Montreal", ar: "مونتريال" }, country: { en: "Canada", ar: "كندا" }, price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-3", type: "city", content: { en: "Vancouver", ar: "فانكوفر" }, country: { en: "Canada", ar: "كندا" }, price: countryBasePrices["Canada"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Canada"]), owner: null },
                { id: "cell-bottom-4", type: "city", content: { en: "Rio de Janeiro", ar: "ريو دي جانيرو" }, country: { en: "Brazil", ar: "البرازيل" }, price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },

                // Index 25: Internet Company
                { id: "cell-bottom-5", type: "company", content: { en: "Internet", ar: "الإنترنت" }, price: 150, emoji: "🌐", rentLevels: [15], boardIndex: 25, owner: null },

                // Bottom Row Cities (Brazil, Argentina)
                { id: "cell-bottom-6", type: "city", content: { en: "Sao Paulo", ar: "ساو باولو" }, country: { en: "Brazil", ar: "البرازيل" }, price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },
                { id: "cell-bottom-7", type: "city", content: { en: "Brasilia", ar: "برازيليا" }, country: { en: "Brazil", ar: "البرازيل" }, price: countryBasePrices["Brazil"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Brazil"]), owner: null },
                { id: "cell-bottom-8", type: "city", content: { en: "Buenos Aires", ar: "بوينس آيرس" }, country: { en: "Argentina", ar: "الأرجنتين" }, price: countryBasePrices["Argentina"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Argentina"]), owner: null },
                { id: "cell-bottom-9", type: "city", content: { en: "Cordoba", ar: "قرطبة" }, country: { en: "Argentina", ar: "الأرجنتين" }, price: countryBasePrices["Argentina"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Argentina"]), owner: null },

                // Index 30: Vacation
                { id: "cell-bottom-right-corner", type: "corner", content: { en: "Vacation", ar: "إجازة" }, emoji: "🏖️", boardIndex: 30, owner: null },

                // Right Column Cities (Egypt, India, Mexico)
                { id: "cell-right-1", type: "city", content: { en: "Cairo", ar: "القاهرة" }, country: { en: "Egypt", ar: "مصر" }, price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-2", type: "city", content: { en: "Alexandria", ar: "الإسكندرية" }, country: { en: "Egypt", ar: "مصر" }, price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-3", type: "city", content: { en: "Giza", ar: "الجيزة" }, country: { en: "Egypt", ar: "مصر" }, price: countryBasePrices["Egypt"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Egypt"]), owner: null },
                { id: "cell-right-4", type: "city", content: { en: "Mumbai", ar: "مومباي" }, country: { en: "India", ar: "الهند" }, price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },

                // Index 35: Airport Company
                { id: "cell-right-5", type: "company", content: { en: "Airport", ar: "المطار" }, price: 2000, emoji: "✈️", rentLevels: [15], boardIndex: 35, owner: null },

                // Right Column Cities (India, Mexico)
                { id: "cell-right-6", type: "city", content: { en: "Delhi", ar: "دلهي" }, country: { en: "India", ar: "الهند" }, price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },
                { id: "cell-right-7", type: "city", content: { en: "Bangalore", ar: "بنغالور" }, country: { en: "India", ar: "الهند" }, price: countryBasePrices["India"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["India"]), owner: null },
                { id: "cell-right-8", type: "city", content: { en: "Mexico City", ar: "مدينة مكسيكو" }, country: { en: "Mexico", ar: "المكسيك" }, price: countryBasePrices["Mexico"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Mexico"]), owner: null },
                { id: "cell-right-9", type: "city", content: { en: "Guadalajara", ar: "غوادالاخارا" }, country: { en: "Mexico", ar: "المكسيك" }, price: countryBasePrices["Mexico"], currentUpgradeLevel: 0, rentLevels: generateRentLevels(countryBasePrices["Mexico"]), owner: null }
            ];


            const gameBoardGrid = document.querySelector('.game-board-grid');
            if (!gameBoardGrid) {
                console.error("Game board grid element not found!");
                return;
            }
            gameBoardGrid.innerHTML = ''; // Clear existing cells

            gameState.boardCellsInfo.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('board-cell');
                cellElement.classList.add(boardPath[index]); // Add the specific class for grid positioning
                if (cell.type === 'corner') {
                    cellElement.classList.add('corner-cell');
                }

                // Add click listener for property details modal
                if (cell.type === 'city' || cell.type === 'company') {
                    cellElement.addEventListener('click', () => displayPropertyDetails(cell.id));
                }

                gameBoardGrid.appendChild(cellElement); // Append the element first

                // Then, update its display content
                updateBoardCellDisplay(cellElement, cell);
            });

            // Re-append the center area after all cells are added
            const boardCenter = document.createElement('div');
            boardCenter.classList.add('board-center');
            boardCenter.innerHTML = `
                <div id="randomNumberDisplay" class="text-white text-5xl font-bold mb-4"></div>
                <div id="turnTimerDisplay" class="text-red-400 text-3xl font-bold mb-4 hidden"></div>
                <button
                    id="rollDiceButton"
                    class="btn-primary flex items-center justify-center text-white text-2xl font-bold py-4 px-12 rounded-xl focus:outline-none focus:ring-4 focus->ring-purple-500 focus:ring-opacity-50"
                >
                    ${getTranslation('play')}
                </button>
            `;
            gameBoardGrid.appendChild(boardCenter);

            // Re-attach event listener for the new rollDiceButton
            const newRollDiceButton = document.getElementById('rollDiceButton');
            if (newRollDiceButton) {
                newRollDiceButton.addEventListener('click', handleRollDice);
            }
        }

        // Helper function for async delay
        const delay = ms => new Promise(res => setTimeout(res, ms));

        // Define positions within a cell for up to 5 players
        const playerTokenOffsets = [
            { x: '10%', y: '10%' }, // Top-left
            { x: '70%', y: '10%' }, // Top-right
            { x: '10%', y: '70%' }, // Bottom-left
            { x: '70%', y: '70%' }, // Bottom-right
            { x: '40%', y: '40%' }  // Center
        ];

        // Function to create and add player tokens to the board
        function addPlayerTokens() {
            gameState.players.forEach((player, playerIdx) => {
                let playerToken = document.getElementById(`player-token-${player.id}`);
                if (!playerToken) {
                    playerToken = document.createElement('div');
                    playerToken.id = `player-token-${player.id}`;
                    playerToken.classList.add('player-token', `player-color-${playerIdx + 1}`); // Assign color based on player index
                    playerToken.textContent = player.name.substring(0, 1).toUpperCase(); // Display first letter of name
                }

                // Set initial position to "Start" cell and apply offset
                const targetCell = document.querySelector(`.${boardPath[player.positionIndex]}`);
                if (targetCell) {
                    targetCell.appendChild(playerToken);
                    // Apply initial offset based on player's index within the cell
                    const playersOnThisCell = Array.from(targetCell.querySelectorAll('.player-token'));
                    const playerIndexInCell = playersOnThisCell.indexOf(playerToken);
                    const offset = playerTokenOffsets[playerIndexInCell % playerTokenOffsets.length];
                    playerToken.style.left = offset.x;
                    playerToken.style.top = offset.y;
                    playerToken.style.transform = `translate(-50%, -50%)`; // Center the token within its offset position
                }
            });
            updatePlayersList(); // Initial highlight for current player
        }

        // Function to update players list in sidebar
        function updatePlayersList() {
            const playersListElem = document.getElementById('playersList');
            if (!playersListElem) return;

            playersListElem.innerHTML = ''; // Clear current list

            gameState.players.forEach((player, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                if (index === gameState.currentPlayerIndex) {
                    listItem.classList.add('current-player-highlight'); // Highlight current player in sidebar
                }
                // Updated innerHTML to include the money-change span
                listItem.innerHTML = `
                    <span>
                        <i class="fas fa-user-circle mr-2" style="color: ${player.color};"></i> ${player.name}
                        <span id="player-money-change-${player.id}" class="money-change"></span>
                    </span>
                    <span class="flex items-center gap-2">
                        <span class="text-green-400">$<span id="player-money-${player.id}">${player.money}</span></span>
                        <button class="text-blue-400 hover:text-blue-200 text-sm" onclick="openTradeCreationModal('${gameState.currentUser.id}')">
                            <i class="fas fa-handshake"></i>
                        </button>
                    </span>
                `;
                playersListElem.appendChild(listItem);
            });

            // Update player token highlight on the board
            gameState.players.forEach((player, index) => {
                const playerToken = document.getElementById(`player-token-${player.id}`);
                if (playerToken) {
                    if (index === gameState.currentPlayerIndex) {
                        playerToken.classList.add('current-player-highlight');
                    } else {
                        playerToken.classList.remove('current-player-highlight');
                    }
                }
            });
        }

        // Function to update player's properties list
        function updateMyPropertiesList() {
            const myPropertiesListElem = document.getElementById('myPropertiesList');
            const myPropertiesCountElem = document.getElementById('myPropertiesCount');
            const currentPlayer = gameState.currentUser; // Get current logged-in player

            if (!myPropertiesListElem || !myPropertiesCountElem) return;

            if (!currentPlayer) {
                myPropertiesListElem.innerHTML = `<li class="text-sm text-gray-400">${getTranslation('noProperties')}</li>`;
                myPropertiesCountElem.textContent = '0';
                return;
            }

            // Filter properties that belong to the current player
            const playerProperties = Object.values(gameState.boardProperties).filter(
                prop => prop.ownerId === currentPlayer.id
            );

            myPropertiesListElem.innerHTML = ''; // Clear current list
            myPropertiesCountElem.textContent = playerProperties.length;

            if (playerProperties.length === 0) {
                const listItem = document.createElement('li');
                listItem.classList.add('text-sm', 'text-gray-400');
                listItem.textContent = getTranslation('noProperties');
                myPropertiesListElem.appendChild(listItem);
            } else {
                playerProperties.forEach(prop => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('text-sm', 'text-gray-300', 'py-0.5', 'flex', 'items-center', 'gap-2'); // Added flex for alignment

                    // Find the original cell info to get type, country, and emoji
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);

                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        // Display country flag then city name
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])} `;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }

                    listItem.innerHTML = `
                        ${iconHtml}
                        <span>${propertyDisplayName} ($${prop.price})</span>
                    `; // Use originalCell.content for full name in list
                    myPropertiesListElem.appendChild(listItem);
                });
            }
        }

        // Function to check and update button state based on debt
        function checkPlayerDebtStatus() {
            const rollDiceButton = document.getElementById('rollDiceButton');
            if (!rollDiceButton) return;

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            if (!currentPlayer) { // If no current player (e.g., game just ended)
                rollDiceButton.disabled = true;
                return;
            }

            // If the current player is indebted, disable the button
            if (currentPlayer.money < 0) {
                rollDiceButton.disabled = true;
                resetTurnTimer(); // Pause the timer if indebted
                // If the button text is "PLAY", it means they haven't rolled yet.
                // If it's "END", they already rolled and are now indebted.
                // In both cases, they cannot proceed until debt is cleared.
            } else {
                // If money is non-negative, enable the button if it's currently disabled
                // and the game is ready for a roll or an end turn.
                if (rollDiceButton.disabled) {
                    // Only re-enable if the button is supposed to be active for the current player's turn
                    // This prevents enabling it prematurely if it's disabled for other reasons (e.g., during movement)
                    if (rollDiceButton.textContent === getTranslation('play') || rollDiceButton.textContent === 'END') { // 'END' is not translated
                         rollDiceButton.disabled = false;
                    }
                }
                // If the player was indebted and cleared it, restart the timer if it was paused
                if (turnTimer === null && rollDiceButton.textContent === 'END') {
                    startTurnTimer();
                }
            }
        }

        // --- Timer Functions ---
        function startTurnTimer() {
            // Clear any existing timer to prevent multiple intervals running
            if (turnTimer) {
                clearInterval(turnTimer);
                console.log(`[Timer Debug] ${Date.now()}: Cleared existing timer ID ${turnTimer} before starting new one.`);
                turnTimer = null; // Ensure it's nullified
            }

            const turnTimerDisplay = document.getElementById('turnTimerDisplay');
            if (turnTimerDisplay) turnTimerDisplay.classList.remove('hidden'); // Show timer display
            timeLeft = TURN_DURATION_SECONDS;
            updateTimerDisplay(); // Initial display update

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            console.log(`[Timer Debug] ${Date.now()}: Starting timer for ${currentPlayer?.name || 'unknown player'} (ID: ${currentPlayer?.id}). Initial time left: ${timeLeft}s. Current player index: ${gameState.currentPlayerIndex}. Total players: ${gameState.players.length}.`);

            turnTimer = setInterval(() => {
                const currentCheckPlayer = gameState.players[gameState.currentPlayerIndex]; // Get player inside interval for current check
                if (!currentCheckPlayer) {
                    console.log(`[Timer Debug] ${Date.now()}: No current player found in interval (player might have been kicked or game ended). Stopping timer.`);
                    resetTurnTimer();
                    return;
                }

                if (currentCheckPlayer.money < 0) {
                    console.log(`[Timer Debug] ${Date.now()}: Timer paused for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.id}). Money: ${currentCheckPlayer.money}. Time left: ${timeLeft}s. Timer ID: ${turnTimer}.`);
                    updateTimerDisplay(); // Still update to show current time, but it won't decrement
                    return;
                }

                timeLeft--;
                updateTimerDisplay();
                console.log(`[Timer Debug] ${Date.now()}: Timer ticked for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.id}). Time left: ${timeLeft}s. Timer ID: ${turnTimer}.`);

                if (timeLeft <= 0) {
                    console.log(`[Timer Debug] ${Date.now()}: Time ran out for ${currentCheckPlayer.name} (ID: ${currentCheckPlayer.id}). Kicking player. Timer ID: ${turnTimer}.`);
                    clearInterval(turnTimer); // Stop the interval immediately
                    turnTimer = null; // Nullify the timer ID
                    kickPlayer(); // Trigger kick logic
                }
            }, 1000);
            console.log(`[Timer Debug] ${Date.now()}: New timer set with ID: ${turnTimer}`);
        }

        function resetTurnTimer() {
            console.log(`[Timer Debug] ${Date.now()}: resetTurnTimer called. Attempting to clear timer ID: ${turnTimer}.`);
            if (turnTimer) {
                clearInterval(turnTimer);
                console.log(`[Timer Debug] ${Date.now()}: Successfully cleared timer ID: ${turnTimer}.`);
                turnTimer = null; // Explicitly set to null
            }
            timeLeft = 0;
            updateTimerDisplay();
            const turnTimerDisplay = document.getElementById('turnTimerDisplay');
            if (turnTimerDisplay) turnTimerDisplay.classList.add('hidden'); // Hide timer display
        }

        function updateTimerDisplay() {
            const turnTimerDisplay = document.getElementById('turnTimerDisplay');
            if (!turnTimerDisplay) return;

            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            turnTimerDisplay.textContent =
                `${getTranslation('timeLeft')}: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Function to kick a player from the game (due to timer)
        function kickPlayer() {
            console.log(`[Player Kick Debug] ${Date.now()}: kickPlayer called. Before kick - Current player index: ${gameState.currentPlayerIndex}. Total players: ${gameState.players.length}. Players array:`, gameState.players.map(p => p.name));
            const kickedPlayer = gameState.players[gameState.currentPlayerIndex];
            if (!kickedPlayer) {
                console.error(`[Player Kick Error] ${Date.now()}: No player to kick at current index ${gameState.currentPlayerIndex}. This should not happen if called from timer.`);
                return;
            }

            // Ensure timer is fully stopped before modifying player state
            resetTurnTimer();

            alert(getTranslation('timeExpired', kickedPlayer.name));
            console.log(`[Player Kick Debug] ${Date.now()}: Alert shown for ${kickedPlayer.name}.`);

            // Revert properties owned by the kicked player
            Object.keys(gameState.boardProperties).forEach(propId => {
                if (gameState.boardProperties[propId].ownerId === kickedPlayer.id) {
                    const propertyInCellsInfo = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (propertyInCellsInfo) {
                        propertyInCellsInfo.owner = null;
                        propertyInCellsInfo.currentUpgradeLevel = 0;
                        const cellElement = document.querySelector(`.${propId}`);
                        if (cellElement) updateBoardCellDisplay(cellElement, propertyInCellsInfo);
                    }
                    delete gameState.boardProperties[propId];
                }
            });
            console.log(`[Player Kick Debug] ${Date.now()}: Properties reverted for ${kickedPlayer.name}.`);

            // Remove player token from the board
            const playerToken = document.getElementById(`player-token-${kickedPlayer.id}`);
            if (playerToken) {
                playerToken.remove();
                console.log(`[Player Kick Debug] ${Date.now()}: Token removed for ${kickedPlayer.name}.`);
            }

            // Remove player from the game state
            gameState.players.splice(gameState.currentPlayerIndex, 1);
            console.log(`[Player Kick Debug] ${Date.now()}: Player ${kickedPlayer.name} removed from array. Remaining players: ${gameState.players.length}. Players array after splice:`, gameState.players.map(p => p.name));

            // If the kicked player was the leader, reassign leaderId
            if (kickedPlayer.id === gameState.leaderId && gameState.players.length > 0) {
                gameState.leaderId = gameState.players[0].id; // Assign new leader
            } else if (gameState.players.length === 0) {
                gameState.leaderId = null; // No leader if no players
            }


            if (gameState.players.length === 0) {
                alert(getTranslation('allPlayersRemoved'));
                console.log(`[Game Over] ${Date.now()}: No players left. Game Over.`);
                const gamePage = document.getElementById('gamePage');
                if (gamePage) gamePage.classList.add('hidden');
                const lobbyPage = document.getElementById('lobbyPage');
                if (lobbyPage) lobbyPage.classList.remove('hidden');
                // Reset game state for new local game
                gameState.players = [];
                gameState.boardProperties = {};
                gameState.pendingTradeOffers = [];
                gameState.leaderId = null;
                return;
            }

            // Adjust currentPlayerIndex if necessary
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                gameState.currentPlayerIndex = 0;
                console.log(`[Player Kick Debug] ${Date.now()}: Current player index adjusted to 0 (was out of bounds).`);
            }
            console.log(`[Player Kick Debug] ${Date.now()}: After kick - New current player index: ${gameState.currentPlayerIndex}. Next player: ${gameState.players[gameState.currentPlayerIndex]?.name}.`);

            // Update UI for the new current player
            updatePlayersList();
            updateMyPropertiesList();
            updatePendingTradesList(); // This will filter out trades involving the kicked player
            checkPlayerDebtStatus(); // Check next player's debt status to disable button if needed

            // Start the timer for the next player's turn, ONLY IF there are players left
            if (gameState.players.length > 0) {
                startTurnTimer();
            }
            updateLobbyPlayerCards(); // Update lobby cards to reflect removal and potential new leader
        }


        // Function to handle dice roll and player movement
        async function handleRollDice() {
            const randomNumberDisplay = document.getElementById('randomNumberDisplay');
            const rollDiceButton = document.getElementById('rollDiceButton');
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            if (!randomNumberDisplay || !rollDiceButton || !currentPlayer) return;

            // Removed the check: if (currentPlayer.id !== gameState.currentUser.id) { alert("It's not your turn!"); return; }
            // This allows the human player to control all turns for testing.

            // Check if the current player is indebted before allowing them to roll
            if (currentPlayer.money < 0) {
                alert(getTranslation('playerInDebt', currentPlayer.name, currentPlayer.money));
                rollDiceButton.disabled = true; // Ensure the button is disabled
                return; // Prevent rolling the dice
            }

            rollDiceButton.disabled = true; // Disable roll button immediately
            resetTurnTimer(); // Stop the timer while dice are rolling and moving
            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} (ID: ${currentPlayer.id}) rolling dice. Timer reset.`);

            const roll = Math.floor(Math.random() * 6) + 1;
            randomNumberDisplay.textContent = roll;
            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} rolled: ${roll}`);

            const playerToken = document.getElementById(`player-token-${currentPlayer.id}`);
            if (playerToken) playerToken.classList.add('moving'); // Add moving class for visual effect

            const oldPositionIndex = currentPlayer.positionIndex;
            let currentPosition = oldPositionIndex;

            // Animate player token movement step by step
            for (let i = 1; i <= roll; i++) {
                currentPosition = (oldPositionIndex + i) % boardPath.length;
                const nextCellId = boardPath[currentPosition];
                const nextCell = document.querySelector(`.${nextCellId}`);

                if (nextCell && playerToken) {
                    // Temporarily move token to the next cell's container
                    nextCell.appendChild(playerToken);

                    // Re-apply the offset for the player in the new cell
                    const playersOnThisCell = Array.from(nextCell.querySelectorAll('.player-token'));
                    const playerIndexInCell = playersOnThisCell.indexOf(playerToken);
                    const offset = playerTokenOffsets[playerIndexInCell % playerTokenOffsets.length];
                    playerToken.style.left = offset.x;
                    playerToken.style.top = offset.y;
                    playerToken.style.transform = `translate(-50%, -50%)`; // Center the token within its offset position
                }
                await delay(300); // Wait for 300ms for visual animation
            }

            if (playerToken) playerToken.classList.remove('moving'); // Remove moving class after animation
            currentPlayer.positionIndex = currentPosition; // Update final position

            // Check if player passes or lands on Start (index 0)
            if ((oldPositionIndex + roll) >= boardPath.length && oldPositionIndex !== 0) {
                currentPlayer.money += gameState.PASS_GO_MONEY;
                alert(getTranslation('playerPassedStart', currentPlayer.name, gameState.PASS_GO_MONEY));
                showMoneyEffect(currentPlayer.id, gameState.PASS_GO_MONEY, 'gain'); // Visual effect for money gain
                updatePlayersList(); // Update player's money display
                console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} passed Start. Money: ${currentPlayer.money}`);
            }

            console.log(`[Roll Dice Debug] ${Date.now()}: Player ${currentPlayer.name} moved to cell: ${boardPath[currentPlayer.positionIndex]} (Index: ${currentPlayer.positionIndex}).`);

            // Handle landing on the cell
            handleLandingOnCell(currentPlayer, boardPath[currentPlayer.positionIndex]);

            // Change button text to "END" after movement and cell action
            rollDiceButton.textContent = 'END';
            rollDiceButton.removeEventListener('click', handleRollDice); // Remove old listener
            rollDiceButton.addEventListener('click', endTurn); // Add new listener for ending turn
            checkPlayerDebtStatus(); // Check debt status after landing and potentially going into debt
            if (currentPlayer.money >= 0) { // Only start timer if not indebted
                startTurnTimer(); // Start the timer after the player has finished their action
            }
            console.log(`[Roll Dice Debug] ${Date.now()}: Roll dice sequence for ${currentPlayer.name} completed. Button changed to 'END'.`);
        }

        // Function to handle actions when a player lands on a cell
        function handleLandingOnCell(player, cellId) {
            console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} (ID: ${player.id}) landed on cell: ${cellId}.`);

            const landedCellInfo = gameState.boardCellsInfo.find(cell => cell.id === cellId);

            if (!landedCellInfo) {
                console.error(`[Cell Land Error] ${Date.now()}: Landed on unknown cell: ${cellId}`);
                return; // Do not call endTurn here, rely on the "END" button
            }

            let propertyDisplayName = landedCellInfo.content[gameState.currentLanguage] || landedCellInfo.content['en'] || landedCellInfo.content;

            if (landedCellInfo.type === 'city' || landedCellInfo.type === 'company') {
                // Check if property is owned
                if (landedCellInfo.owner === null) {
                    // Show buy option
                    console.log(`[Cell Land Debug] ${Date.now()}: Landed on unowned property: ${propertyDisplayName}. Displaying buy option.`);
                    displayBuyOption(player, landedCellInfo);
                } else if (landedCellInfo.owner !== player.id) {
                    // Property is owned by another player - handle rent
                    const ownerPlayer = gameState.players.find(p => p.id === landedCellInfo.owner);
                    const rentAmount = landedCellInfo.rentLevels[landedCellInfo.currentUpgradeLevel]; // Use rent from current upgrade level

                    player.money -= rentAmount;
                    if (ownerPlayer) ownerPlayer.money += rentAmount; // Check ownerPlayer
                    updatePlayersList();
                    showMoneyEffect(player.id, rentAmount, 'loss'); // Visual effect for money loss
                    if (ownerPlayer) showMoneyEffect(ownerPlayer.id, rentAmount, 'gain'); // Visual effect for money gain

                    if (player.money < 0) {
                        alert(getTranslation('playerInDebt', player.name, player.money));
                        console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} in debt. Money: ${player.money}.`);
                    } else {
                        alert(getTranslation('landedOnOwned', propertyDisplayName, ownerPlayer ? ownerPlayer.name : 'Unknown', rentAmount, player.name)); // Check ownerPlayer
                        console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} paid rent. Money: ${player.money}.`);
                    }
                    checkPlayerDebtStatus(); // Check debt status after rent payment
                } else {
                    // Landed on own property
                    alert(getTranslation('landedOnOwn', propertyDisplayName));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on own property.`);
                }
            } else if (landedCellInfo.type === 'corner') {
                // Handle corner actions
                if (landedCellInfo.content[gameState.currentLanguage] === getTranslation("goToJail")) {
                    alert(getTranslation('landedOnJail', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Go to Jail.`);
                } else if (landedCellInfo.content[gameState.currentLanguage] === getTranslation("surprise")) {
                    alert(getTranslation('landedOnSurprise', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Surprise.`);
                } else if (landedCellInfo.content[gameState.currentLanguage] === getTranslation("vacation")) {
                    alert(getTranslation('landedOnVacation', player.name));
                    console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on Vacation.`);
                }
            } else {
                // Other types of cells (e.g., tax, bonus cards - future expansion)
                alert(getTranslation('landedOnMisc', propertyDisplayName));
                console.log(`[Cell Land Debug] ${Date.now()}: Player ${player.name} landed on miscellaneous cell: ${propertyDisplayName}.`);
            }
            // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
        }

        // Function to display the buy property modal
        function displayBuyOption(player, property) {
            const buyModal = document.getElementById('buyPropertyModal');
            const modalTitle = document.getElementById('propertyModalTitle');
            const modalPrice = document.getElementById('propertyModalPrice');
            const playerMoneyDisplay = document.getElementById('playerCurrentMoney');
            const buyButton = document.getElementById('buyPropertyBtn');
            const cancelButton = document.getElementById('cancelBuyBtn');

            if (!buyModal || !modalTitle || !modalPrice || !playerMoneyDisplay || !buyButton || !cancelButton) return;

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;

            modalTitle.textContent = getTranslation('buyPropertyQuestion', propertyDisplayName);
            modalPrice.textContent = `$${property.price}`;
            playerMoneyDisplay.textContent = `$${player.money}`;

            buyModal.classList.remove('hidden');
            console.log(`[Buy Option Debug] ${Date.now()}: Buy property modal displayed for: ${propertyDisplayName}. Player: ${player.name}.`);


            // Clear previous listeners to prevent multiple bindings
            buyButton.onclick = null;
            cancelButton.onclick = null;

            buyButton.onclick = () => {
                if (player.money >= property.price) {
                    player.money -= property.price;
                    property.owner = player.id; // Assign owner ID
                    gameState.boardProperties[property.id] = { // Store ownership in gameState
                        id: property.id,
                        content: property.content, // Use content for property name
                        price: property.price, // Store original purchase price
                        ownerId: player.id,
                        currentUpgradeLevel: property.currentUpgradeLevel // Store initial upgrade level
                    };

                    // Find the cell element to update its color bar
                    const cellElement = document.querySelector(`.${property.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, property); // Update the cell display after purchase
                    }


                    updatePlayersList();
                    updateMyPropertiesList();
                    alert(getTranslation('playerBought', player.name, propertyDisplayName, property.price));
                    showMoneyEffect(player.id, property.price, 'loss'); // Visual effect for money loss
                    buyModal.classList.add('hidden');
                    console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} bought ${propertyDisplayName}. Money: ${player.money}.`);
                } else {
                    // Allow buying with negative money, but player becomes indebted
                    player.money -= property.price;
                    property.owner = player.id;
                    gameState.boardProperties[property.id] = {
                        id: property.id,
                        content: property.content,
                        price: property.price,
                        ownerId: player.id,
                        currentUpgradeLevel: property.currentUpgradeLevel
                    };

                    const cellElement = document.querySelector(`.${property.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, property);
                    }

                    updatePlayersList();
                    updateMyPropertiesList();
                    alert(getTranslation('playerInDebt', player.name, player.money));
                    showMoneyEffect(player.id, property.price, 'loss');
                    buyModal.classList.add('hidden');
                    console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} bought ${propertyDisplayName} and went into debt. Money: ${player.money}.`);
                }
                checkPlayerDebtStatus(); // Check debt status after purchase
                // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
            };

            cancelButton.onclick = () => {
                buyModal.classList.add('hidden');
                alert(getTranslation('playerPassed', player.name, propertyDisplayName));
                console.log(`[Buy Option Debug] ${Date.now()}: Player ${player.name} passed on ${propertyDisplayName}.`);
                checkPlayerDebtStatus(); // Check debt status (in case they were already indebted)
                // IMPORTANT: Do NOT call endTurn() here. The "END" button handles turn progression.
            };
        }

        // Function to check if a player owns all cities of a specific country
        function checkCountryOwnership(player, country) {
            const countryCities = gameState.boardCellsInfo.filter(cell => cell.type === 'city' && (cell.country[gameState.currentLanguage] === country || cell.country['en'] === country));
            if (countryCities.length === 0) {
                return false; // No cities for this country defined
            }
            return countryCities.every(city => gameState.boardProperties[city.id] && gameState.boardProperties[city.id].ownerId === player.id);
        }

        // Function to display property details modal
        function displayPropertyDetails(cellId) {
            const propertyDetailsModal = document.getElementById('propertyDetailsModal');
            const propertyDetailIcon = document.getElementById('propertyDetailIcon');
            const propertyDetailName = document.getElementById('propertyDetailName');
            const propertyDetailPrice = document.getElementById('propertyDetailPrice');
            const propertyRentLevelsList = document.getElementById('propertyRentLevels');
            const currentUpgradeLevelDisplay = document.getElementById('currentUpgradeLevelDisplay');
            const upgradePropertyBtn = document.getElementById('upgradePropertyBtn');
            const downgradePropertyBtn = document.getElementById('downgradePropertyBtn');
            const upgradeCostText = document.getElementById('upgradeCostText'); // New span for upgrade cost
            const downgradeRefundText = document.getElementById('downgradeRefundText'); // New span for downgrade refund
            const upgradeSection = document.getElementById('upgradeSection');

            if (!propertyDetailsModal || !propertyDetailIcon || !propertyDetailName || !propertyDetailPrice || !propertyRentLevelsList || !currentUpgradeLevelDisplay || !upgradePropertyBtn || !downgradePropertyBtn || !upgradeCostText || !downgradeRefundText || !upgradeSection) return;

            const property = gameState.boardCellsInfo.find(cell => cell.id === cellId);
            const currentPlayer = gameState.currentUser; // Get current logged-in player

            if (!property) {
                console.error("Property not found for details:", cellId);
                return;
            }

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;
            let propertyCountryName = property.country ? (property.country[gameState.currentLanguage] || property.country['en'] || property.country) : '';

            // Populate modal content
            propertyDetailName.textContent = propertyDisplayName;
            propertyDetailPrice.textContent = `$${property.price}`;

            // Set icon (flag or emoji)
            if (property.type === 'city') {
                propertyDetailIcon.innerHTML = getCountryFlagImage(propertyCountryName); // Still use country flag for property details modal
            } else if (property.type === 'company') {
                propertyDetailIcon.innerHTML = `<span class="text-3xl">${getCompanyEmoji(propertyDisplayName)}</span>`;
            }

            // Populate rent levels
            propertyRentLevelsList.innerHTML = '';
            let rentLevelLabels;
            if (property.type === 'city') {
                rentLevelLabels = [getTranslation("baseRent"), `${getTranslation("level")} 1`, `${getTranslation("level")} 2`, `${getTranslation("level")} 3`, `${getTranslation("level")} 4`];
            } else if (property.type === 'company') {
                rentLevelLabels = [getTranslation("baseRent")]; // Only base rent for companies
            } else {
                rentLevelLabels = [getTranslation("baseRent"), `${getTranslation("level")} 1`, `${getTranslation("level")} 2`, `${getTranslation("level")} 3`, `${getTranslation("level")} 4`]; // Fallback
            }

            property.rentLevels.forEach((rent, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('rent-level-item');
                if (index === property.currentUpgradeLevel) {
                    listItem.classList.add('current-rent');
                }
                listItem.innerHTML = `<span>${rentLevelLabels[index]}:</span> <span>$${rent}</span>`;
                propertyRentLevelsList.appendChild(listItem);
            });

            // Show upgrade section only if owned by current player and it's a city
            if (currentPlayer && property.owner === currentPlayer.id && property.type === 'city') {
                upgradeSection.classList.remove('hidden');
                currentUpgradeLevelDisplay.textContent = `${getTranslation('level')} ${property.currentUpgradeLevel}`; // Display "Level X"

                const ownsAllCountryCities = checkCountryOwnership(currentPlayer, propertyCountryName);

                // Calculate and display next upgrade cost
                if (property.currentUpgradeLevel < property.rentLevels.length - 1 && ownsAllCountryCities) {
                    const nextRentLevelValue = property.rentLevels[property.currentUpgradeLevel + 1];
                    const upgradeCost = roundToNearestFive(nextRentLevelValue * 0.5); // 50% of the next rent price, rounded to nearest 5
                    upgradeCostText.textContent = `$${upgradeCost}`;
                    upgradePropertyBtn.disabled = currentPlayer.money < upgradeCost;
                } else {
                    upgradeCostText.textContent = getTranslation("max"); // Indicate max level
                    upgradePropertyBtn.disabled = true;
                }

                // Calculate and display downgrade refund amount
                if (property.currentUpgradeLevel > 0) {
                    const currentRentLevelValue = property.rentLevels[property.currentUpgradeLevel];
                    const refundedAmount = roundToNearestFive(currentRentLevelValue * 0.5); // Refund 50% of current level rent, rounded to nearest 5
                    downgradeRefundText.textContent = `$${refundedAmount}`;
                    downgradePropertyBtn.disabled = false;
                } else {
                    downgradeRefundText.textContent = getTranslation("min"); // Indicate min level
                    downgradePropertyBtn.disabled = true;
                }

                // Re-attach listeners to prevent multiple bindings
                upgradePropertyBtn.onclick = () => handleUpgradeProperty(property.id);
                downgradePropertyBtn.onclick = () => handleDowngradeProperty(property.id);

            } else {
                upgradeSection.classList.add('hidden'); // Hide upgrade section if not owned by current player or if it's a company
            }

            propertyDetailsModal.classList.remove('hidden');
            console.log(`[Property Details Debug] ${Date.now()}: Property details modal displayed for: ${propertyDisplayName}.`);
        }

        // Handle property upgrade
        function handleUpgradeProperty(propertyId) {
            const property = gameState.boardCellsInfo.find(cell => cell.id === propertyId);
            const currentPlayer = gameState.currentUser;

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;
            let propertyCountryName = property.country ? (property.country[gameState.currentLanguage] || property.country['en'] || property.country) : '';

            if (!property || property.owner !== currentPlayer.id || property.type !== 'city') { // Ensure it's a city owned by current player
                alert(getTranslation("notOwnedOrExists"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Not owned by current player or not a city.`);
                return;
            }

            const ownsAllCountryCities = checkCountryOwnership(currentPlayer, propertyCountryName);
            if (!ownsAllCountryCities) {
                alert(getTranslation('mustOwnAllCities', propertyCountryName));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Does not own all cities in country.`);
                return;
            }

            if (property.currentUpgradeLevel >= property.rentLevels.length - 1) { // Check against rentLevels length
                alert(getTranslation("maxLevel"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Max level reached.`);
                return;
            }

            const nextRentLevelValue = property.rentLevels[property.currentUpgradeLevel + 1];
            const upgradeCost = roundToNearestFive(nextRentLevelValue * 0.5); // 50% of the next rent price, rounded to nearest 5

            if (currentPlayer.money < upgradeCost) {
                alert(getTranslation("notEnoughMoney"));
                console.warn(`[Upgrade Debug] ${Date.now()}: Upgrade failed. Insufficient money.`);
                return;
            }

            currentPlayer.money -= upgradeCost;
            property.currentUpgradeLevel++;

            // Update the property in gameState.boardProperties as well
            if (gameState.boardProperties[property.id]) {
                gameState.boardProperties[property.id].currentUpgradeLevel = property.currentUpgradeLevel;
            }

            updatePlayersList();
            updateMyPropertiesList(); // This might not show upgrade level, but good to call
            displayPropertyDetails(propertyId); // Re-display modal to update info

            const cellElement = document.querySelector(`.${property.id}`);
            if (cellElement) {
                updateBoardCellDisplay(cellElement, property); // Update the cell display after upgrade
            }

            alert(getTranslation('playerUpgraded', currentPlayer.name, propertyDisplayName, property.currentUpgradeLevel));
            showMoneyEffect(currentPlayer.id, upgradeCost, 'loss'); // Visual effect for money loss
            checkPlayerDebtStatus(); // Check debt status after upgrade
            console.log(`[Upgrade Debug] ${Date.now()}: Player ${currentPlayer.name} upgraded ${propertyDisplayName} to level ${property.currentUpgradeLevel}. Cost: $${upgradeCost}. Money: ${currentPlayer.money}.`);
        }

        // Handle property downgrade
        function handleDowngradeProperty(propertyId) {
            const property = gameState.boardCellsInfo.find(cell => cell.id === propertyId);
            const currentPlayer = gameState.currentUser;

            let propertyDisplayName = property.content[gameState.currentLanguage] || property.content['en'] || property.content;

            if (!property || property.owner !== currentPlayer.id || property.type !== 'city') { // Ensure it's a city owned by current player
                alert(getTranslation("notOwnedOrExists"));
                console.warn(`[Downgrade Debug] ${Date.now()}: Downgrade failed. Not owned by current player or not a city.`);
                return;
            }

            if (property.currentUpgradeLevel <= 0) {
                alert(getTranslation("minLevel"));
                console.warn(`[Downgrade Debug] ${Date.now()}: Downgrade failed. Already at min level.`);
                return;
            }

            // Refund half the cost of the last upgrade (which was 50% of the rent of the level it's downgrading *from*)
            const currentRentLevelValue = property.rentLevels[property.currentUpgradeLevel];
            const refundedAmount = roundToNearestFive(currentRentLevelValue * 0.5); // Refund 50% of current level rent, rounded to nearest 5

            currentPlayer.money += refundedAmount;
            property.currentUpgradeLevel--;

            // Update the property in gameState.boardProperties as well
            if (gameState.boardProperties[property.id]) {
                gameState.boardProperties[property.id].currentUpgradeLevel = property.currentUpgradeLevel;
            }

            updatePlayersList();
            updateMyPropertiesList();
            displayPropertyDetails(propertyId); // Re-display modal to update info

            const cellElement = document.querySelector(`.${property.id}`);
            if (cellElement) {
                updateBoardCellDisplay(cellElement, property); // Update the cell display after downgrade
            }

            alert(getTranslation('playerDowngraded', currentPlayer.name, propertyDisplayName, refundedAmount, property.currentUpgradeLevel));
            showMoneyEffect(currentPlayer.id, refundedAmount, 'gain'); // Visual effect for money gain
            checkPlayerDebtStatus(); // Check debt status after downgrade
            console.log(`[Downgrade Debug] ${Date.now()}: Player ${currentPlayer.name} downgraded ${propertyDisplayName} to level ${property.currentUpgradeLevel}. Refunded: $${refundedAmount}. Money: ${currentPlayer.money}.`);
        }


        // Function to end the current player's turn and switch to the next
        function endTurn() {
            const rollDiceButton = document.getElementById('rollDiceButton');
            if (!rollDiceButton) return;

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];

            // Removed the check: if (currentPlayer.id !== gameState.currentUser.id) { alert("It's not your turn!"); return; }
            // This allows the human player to control all turns for testing.

            console.log(`[End Turn Debug] ${Date.now()}: endTurn called for ${currentPlayer?.name || 'unknown player'} (ID: ${currentPlayer?.id}). Money: ${currentPlayer?.money}.`);

            // Check if the current player is indebted (money is negative)
            if (currentPlayer.money < 0) {
                alert(getTranslation('playerInDebt', currentPlayer.name, currentPlayer.money));
                // Keep the button as "END" and disabled
                rollDiceButton.textContent = 'END';
                rollDiceButton.disabled = true;
                // Re-attach the endTurn listener to itself so it remains in the 'END' state
                rollDiceButton.removeEventListener('click', handleRollDice); // Ensure handleRollDice is removed
                rollDiceButton.removeEventListener('click', endTurn); // Remove existing endTurn listener
                rollDiceButton.addEventListener('click', endTurn); // Re-add endTurn listener
                console.log(`[End Turn Debug] ${Date.now()}: Player ${currentPlayer.name} is in debt. Cannot end turn.`);
                return; // Prevent ending the turn
            }

            // If not indebted, proceed with ending the turn
            resetTurnTimer(); // Stop the timer for the current player
            rollDiceButton.textContent = getTranslation('play');
            rollDiceButton.removeEventListener('click', endTurn);
            rollDiceButton.addEventListener('click', handleRollDice);
            rollDiceButton.disabled = false;

            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            const nextPlayer = gameState.players[gameState.currentPlayerIndex];
            alert(getTranslation('turnEnded', currentPlayer.name, nextPlayer.name));
            console.log(`[End Turn Debug] ${Date.now()}: Turn ended for ${currentPlayer.name}. It's now ${nextPlayer.name}'s turn (ID: ${nextPlayer.id}). New current player index: ${gameState.currentPlayerIndex}.`);
            updatePlayersList(); // Re-render to update money display and highlight
            updateMyPropertiesList(); // Update properties for the new current player
            checkPlayerDebtStatus(); // Check next player's debt status to disable button if needed

            // Start the timer for the next player
            startTurnTimer();
        }

        // --- Trade System Functions ---

        /**
         * Populates the requested properties list based on the selected recipient.
         * @param {string} recipientId - The ID of the player whose properties are to be listed.
         */
        function updateRequestedPropertiesForRecipient(recipientId) {
            const requestedPropertiesList = document.getElementById('requestedPropertiesList');
            if (!requestedPropertiesList) return;

            requestedPropertiesList.innerHTML = ''; // Clear current list

            const recipientPlayerInGame = gameState.players.find(p => p.id === recipientId);

            if (!recipientPlayerInGame) {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToRequest');
                requestedPropertiesList.appendChild(p);
                return;
            }

            const recipientProperties = Object.values(gameState.boardProperties).filter(prop => prop.ownerId === recipientPlayerInGame.id);

            if (recipientProperties.length > 0) {
                recipientProperties.forEach(prop => {
                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2';
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])}`;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }
                    listItem.innerHTML = `
                        <input type="checkbox" id="request-prop-${prop.id}" value="${prop.id}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="request-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${propertyDisplayName}</span>
                        </label>
                    `;
                    requestedPropertiesList.appendChild(listItem);
                });
            } else {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToRequest');
                requestedPropertiesList.appendChild(p);
            }
        }

        /**
         * Opens the trade creation modal, populating it with available options.
         * @param {string} senderId - The ID of the player initiating the trade.
         * @param {object} [existingOffer=null] - Optional: An existing trade offer object to pre-fill the modal for modification.
         */
        function openTradeCreationModal(senderId, existingOffer = null) {
            const tradeCreationModal = document.getElementById('tradeCreationModal');
            const tradeRecipientSelect = document.getElementById('tradeRecipient');
            const offeredPropertiesList = document.getElementById('offeredPropertiesList');
            const offerMoneyInput = document.getElementById('offerMoney');
            const requestMoneyInput = document.getElementById('requestMoney');
            const tradeOfferIdToModify = document.getElementById('tradeOfferIdToModify');

            if (!tradeCreationModal || !tradeRecipientSelect || !offeredPropertiesList || !offerMoneyInput || !requestMoneyInput || !tradeOfferIdToModify) return;

            const senderPlayerInGame = gameState.players.find(p => p.id === senderId);

            if (!senderPlayerInGame) {
                console.error("Sender player not found in current game for trade:", senderId);
                alert("Error: You are not in a game or your player data is missing.");
                return;
            }

            // Clear previous selections/inputs
            offerMoneyInput.value = 0;
            requestMoneyInput.value = 0;
            offeredPropertiesList.innerHTML = '';
            tradeRecipientSelect.innerHTML = '';
            tradeOfferIdToModify.value = ''; // Clear ID for new offers

            // Populate trade recipient dropdown (all players in the game except the sender)
            const otherPlayersInGame = gameState.players.filter(p => p.id !== senderId);
            if (otherPlayersInGame.length === 0) {
                alert(getTranslation("noOtherPlayers"));
                tradeCreationModal.classList.add('hidden');
                return;
            }

            otherPlayersInGame.forEach(player => {
                const option = document.createElement('option');
                option.value = player.id; // Use player ID for recipient
                option.textContent = player.name;
                tradeRecipientSelect.appendChild(option);
            });

            // Set up the change listener for the recipient dropdown
            tradeRecipientSelect.onchange = (event) => {
                const selectedRecipientId = event.target.value;
                updateRequestedPropertiesForRecipient(selectedRecipientId);
            };

            // Populate offered properties (current player's properties)
            const senderProperties = Object.values(gameState.boardProperties).filter(prop => prop.ownerId === senderPlayerInGame.id);
            if (senderProperties.length > 0) {
                senderProperties.forEach(prop => {
                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2';
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])}`;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }
                    listItem.innerHTML = `
                        <input type="checkbox" id="offer-prop-${prop.id}" value="${prop.id}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="offer-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${propertyDisplayName}</span>
                        </label>
                    `;
                    offeredPropertiesList.appendChild(listItem);
                });
            } else {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToOffer');
                offeredPropertiesList.appendChild(p);
            }

            // If an existing offer is provided, pre-fill the modal
            if (existingOffer) {
                const h3 = tradeCreationModal.querySelector('h3');
                if (h3) h3.textContent = getTranslation('modifyTradeOffer');
                tradeOfferIdToModify.value = existingOffer.offerId;
                offerMoneyInput.value = existingOffer.offeredMoney;
                requestMoneyInput.value = existingOffer.requestedMoney;

                // Select recipient
                tradeRecipientSelect.value = existingOffer.recipientId;

                // Check offered properties
                existingOffer.offeredProperties.forEach(propId => {
                    const checkbox = document.getElementById(`offer-prop-${propId}`);
                    if (checkbox) checkbox.checked = true;
                });

                // Update requested properties for the selected recipient and then check them
                updateRequestedPropertiesForRecipient(tradeRecipientSelect.value); // Use tradeRecipientSelect.value here
                setTimeout(() => { // Small delay to ensure properties are rendered
                    existingOffer.requestedProperties.forEach(propId => {
                        const checkbox = document.getElementById(`request-prop-${propId}`); // Corrected: use propId directly
                        if (checkbox) checkbox.checked = true;
                    });
                }, 50);

            } else {
                const h3 = tradeCreationModal.querySelector('h3');
                if (h3) h3.textContent = getTranslation('createTradeOffer');
                // Populate requested properties for the initially selected recipient (only for new offers)
                if (tradeRecipientSelect.value) {
                    updateRequestedPropertiesForRecipient(tradeRecipientSelect.value);
                }
            }

            tradeCreationModal.classList.remove('hidden');
            console.log(`[Trade Debug] ${Date.now()}: Trade creation modal opened for sender ${senderId}. Existing offer: ${existingOffer ? 'yes' : 'no'}.`);
        }

        /**
         * Sends the trade offer based on the values in the trade creation modal.
         */
        function sendTradeOffer() {
            const senderPlayerInGame = gameState.currentUser; // The current logged-in player is the sender
            const recipientId = document.getElementById('tradeRecipient')?.value;
            const offeredMoney = parseInt(document.getElementById('offerMoney')?.value || '0');
            const requestedMoney = parseInt(document.getElementById('requestMoney')?.value || '0');
            const tradeOfferId = document.getElementById('tradeOfferIdToModify')?.value; // Get ID if modifying

            const offeredProperties = Array.from(document.querySelectorAll('#offeredPropertiesList input:checked')).map(cb => cb.value);
            const requestedProperties = Array.from(document.querySelectorAll('#requestedPropertiesList input:checked')).map(cb => cb.value);

            if (!recipientId) {
                alert(getTranslation("selectRecipient"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: No recipient selected.`);
                return;
            }

            if (offeredMoney <= 0 && requestedMoney <= 0 && offeredProperties.length === 0 && requestedProperties.length === 0) {
                alert(getTranslation("specifyItems"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: No items specified.`);
                return;
            }

            // Validate offered money
            if (offeredMoney > senderPlayerInGame.money) {
                alert(getTranslation("insufficientMoneyOffer"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Insufficient money offered by sender.`);
                return;
            }

            // Validate offered properties are actually owned by sender
            const invalidOfferedProps = offeredProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== senderPlayerInGame.id
            );
            if (invalidOfferedProps.length > 0) {
                alert(getTranslation("onlyOwnProperties"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Invalid offered properties.`);
                return;
            }

            // Validate requested properties are actually owned by recipient
            const recipientPlayerInGame = gameState.players.find(p => p.id === recipientId);
            const invalidRequestedProps = requestedProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== recipientPlayerInGame.id
            );
            if (invalidRequestedProps.length > 0) {
                alert(getTranslation("onlyRequestOwned"));
                console.warn(`[Trade Debug] ${Date.now()}: Send trade failed: Invalid requested properties.`);
                return;
            }

            const newTradeOffer = {
                offerId: tradeOfferId ? tradeOfferId : crypto.randomUUID(), // Reuse ID if modifying, otherwise new UUID
                senderId: senderPlayerInGame.id, // Use ID for sender
                recipientId: recipientId, // Use ID for recipient
                offeredMoney: offeredMoney,
                offeredProperties: offeredProperties,
                requestedMoney: requestedMoney,
                requestedProperties: requestedProperties,
                status: "pending",
                timestamp: Date.now()
            };

            // If modifying, remove the old offer before adding the new one
            if (tradeOfferId) {
                gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== tradeOfferId);
                console.log(`[Trade Debug] ${Date.now()}: Modifying existing trade offer ID: ${tradeOfferId}.`);
            }

            gameState.pendingTradeOffers.push(newTradeOffer);
            const tradeCreationModal = document.getElementById('tradeCreationModal');
            if (tradeCreationModal) tradeCreationModal.classList.add('hidden');
            alert(getTranslation('offerSent', recipientPlayerInGame.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer sent. Offer details:`, newTradeOffer);

            updatePendingTradesList(); // Update the public list
        }

        /**
         * Displays an incoming trade offer to the recipient.
         * @param {object} offer - The trade offer object.
         */
        function displayIncomingTradeOffer(offer) {
            const incomingTradeOfferModal = document.getElementById('incomingTradeOfferModal');
            const offerSenderName = document.getElementById('offerSenderName');
            const offerReceivedMoney = document.getElementById('offerReceivedMoney');
            const offerReceivedProperties = document.getElementById('offerReceivedProperties');
            const requestSentMoney = document.getElementById('requestSentMoney');
            const requestSentProperties = document.getElementById('requestSentProperties');

            if (!incomingTradeOfferModal || !offerSenderName || !offerReceivedMoney || !offerReceivedProperties || !requestSentMoney || !requestSentProperties) return;


            const sender = gameState.players.find(p => p.id === offer.senderId);
            if (!sender) {
                console.error(`[Trade Debug] ${Date.now()}: Sender not found for incoming trade offer.`);
                return;
            }

            gameState.currentActiveTradeOffer = offer; // Store the active offer
            console.log(`[Trade Debug] ${Date.now()}: Displaying incoming trade offer from ${sender.name} (ID: ${sender.id}). Offer ID: ${offer.offerId}.`);

            offerSenderName.textContent = sender.name;
            offerReceivedMoney.textContent = offer.offeredMoney;
            requestSentMoney.textContent = offer.requestedMoney;

            offerReceivedProperties.innerHTML = '';
            if (offer.offeredProperties.length > 0) {
                offer.offeredProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        offerReceivedProperties.appendChild(listItem);
                    }
                });
            } else {
                offerReceivedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            requestSentProperties.innerHTML = '';
            if (offer.requestedProperties.length > 0) {
                offer.requestedProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        requestSentProperties.appendChild(listItem);
                    }
                });
            } else {
                requestSentProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            incomingTradeOfferModal.classList.remove('hidden');
        }

        /**
         * Handles the acceptance of the current active trade offer.
         */
        function acceptTrade() {
            const offer = gameState.currentActiveTradeOffer;
            if (!offer) {
                console.error(`[Trade Debug] ${Date.now()}: No active trade offer to accept.`);
                return;
            }

            const sender = gameState.players.find(p => p.id === offer.senderId);
            const recipient = gameState.players.find(p => p.id === offer.recipientId);

            if (!sender || !recipient) {
                alert(getTranslation("tradeError"));
                console.error(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender or recipient not found.`);
                return;
            }

            // Check if sender has enough money to offer
            if (sender.money < offer.offeredMoney) {
                alert(getTranslation('senderInsufficientMoney', sender.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender (${sender.name}) insufficient money.`);
                declineTrade(); // Automatically decline if sender can't pay
                return;
            }

            // Check if recipient has enough money to pay what's requested
            if (recipient.money < offer.requestedMoney) {
                alert(getTranslation('recipientInsufficientMoney', recipient.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Recipient (${recipient.name}) insufficient money.`);
                return; // Recipient can't accept if they don't have enough money
            }

            // Check if sender still owns the properties they are offering
            const senderMissingProps = offer.offeredProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== sender.id
            );
            if (senderMissingProps.length > 0) {
                alert(getTranslation('senderMissingProps', sender.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Sender (${sender.name}) missing offered properties.`);
                declineTrade();
                return;
            }

            // Check if recipient still owns the properties being requested from them
            const recipientMissingProps = offer.requestedProperties.filter(propId =>
                !gameState.boardProperties[propId] || gameState.boardProperties[propId].ownerId !== recipient.id
            );
            if (recipientMissingProps.length > 0) {
                alert(getTranslation("recipientMissingProps", recipient.name));
                console.warn(`[Trade Debug] ${Date.now()}: Accept trade failed: Recipient (${recipient.name}) missing requested properties.`);
                return; // Recipient can't accept if they don't own requested properties
            }


            // Perform money transfer
            sender.money -= offer.offeredMoney;
            recipient.money += offer.offeredMoney;
            showMoneyEffect(sender.id, offer.offeredMoney, 'loss');
            showMoneyEffect(recipient.id, offer.offeredMoney, 'gain');
            console.log(`[Trade Debug] ${Date.now()}: Money transfer: ${sender.name} paid $${offer.offeredMoney} to ${recipient.name}.`);


            sender.money += offer.requestedMoney;
            recipient.money -= offer.requestedMoney;
            showMoneyEffect(sender.id, offer.requestedMoney, 'gain');
            showMoneyEffect(recipient.id, offer.requestedMoney, 'loss');
            console.log(`[Trade Debug] ${Date.now()}: Money transfer: ${recipient.name} paid $${offer.requestedMoney} to ${sender.name}.`);


            // Perform property transfer
            offer.offeredProperties.forEach(propId => {
                const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (prop) {
                    prop.owner = recipient.id;
                    gameState.boardProperties[propId].ownerId = recipient.id;
                    // Update property color bar on the board
                    const cellElement = document.querySelector(`.${prop.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, prop);
                    }
                    console.log(`[Trade Debug] ${Date.now()}: Property ${prop.content[gameState.currentLanguage] || prop.content['en']} transferred from ${sender.name} to ${recipient.name}.`);
                }
            });

            offer.requestedProperties.forEach(propId => {
                const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (prop) {
                    prop.owner = sender.id;
                    gameState.boardProperties[propId].ownerId = sender.id;
                    // Update property color bar on the board
                    const cellElement = document.querySelector(`.${prop.id}`);
                    if (cellElement) {
                        updateBoardCellDisplay(cellElement, prop);
                    }
                    console.log(`[Trade Debug] ${Date.now()}: Property ${prop.content[gameState.currentLanguage] || prop.content['en']} transferred from ${recipient.name} to ${sender.name}.`);
                }
            });

            // Remove the offer from pending offers
            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== offer.offerId);
            gameState.currentActiveTradeOffer = null; // Clear active offer

            const incomingTradeOfferModal = document.getElementById('incomingTradeOfferModal');
            if (incomingTradeOfferModal) incomingTradeOfferModal.classList.add('hidden');
            const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
            if (tradeDetailsViewModal) tradeDetailsViewModal.classList.add('hidden'); // Hide if open
            alert(getTranslation('tradeAccepted', sender.name, recipient.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offer.offerId} accepted.`);

            updatePlayersList();
            updateMyPropertiesList(); // Update properties list for both players
            updatePendingTradesList(); // Update the public list
            checkPlayerDebtStatus(); // Check debt status after trade
        }

        /**
         * Handles the decline of the current active trade offer.
         */
        function declineTrade() {
            const offer = gameState.currentActiveTradeOffer;
            if (!offer) {
                console.error(`[Trade Debug] ${Date.now()}: No active trade offer to decline.`);
                return;
            }

            const sender = gameState.players.find(p => p.id === offer.senderId);
            const recipient = gameState.players.find(p => p.id === offer.recipientId);

            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(o => o.offerId !== offer.offerId);
            gameState.currentActiveTradeOffer = null; // Clear active offer

            const incomingTradeOfferModal = document.getElementById('incomingTradeOfferModal');
            if (incomingTradeOfferModal) incomingTradeOfferModal.classList.add('hidden');
            const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
            if (tradeDetailsViewModal) tradeDetailsViewModal.classList.add('hidden'); // Hide if open
            alert(getTranslation('tradeDeclined', sender.name, recipient.name));
            console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offer.offerId} declined.`);

            updatePendingTradesList(); // Update the public list
            checkPlayerDebtStatus(); // Check debt status after trade
        }

        /**
         * Handles the cancellation of a trade offer by the sender.
         * @param {string} offerId - The ID of the trade offer to cancel.
         */
        function cancelTrade(offerId) {
            const offerIndex = gameState.pendingTradeOffers.findIndex(o => o.offerId === offerId);
            if (offerIndex > -1) {
                const cancelledOffer = gameState.pendingTradeOffers.splice(offerIndex, 1)[0];
                const sender = gameState.players.find(p => p.id === cancelledOffer.senderId);
                const recipient = gameState.players.find(p => p.id === cancelledOffer.recipientId);
                alert(getTranslation('tradeCancelled', sender.name, recipient.name));
                gameState.currentActiveTradeOffer = null; // Clear active offer if it was the one cancelled
                const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
                if (tradeDetailsViewModal) tradeDetailsViewModal.classList.add('hidden'); // Hide if open
                console.log(`[Trade Debug] ${Date.now()}: Trade offer ID ${offerId} cancelled by sender.`);

                updatePendingTradesList(); // Update the public list
                checkPlayerDebtStatus(); // Check debt status after cancellation
            } else {
                console.warn(`[Trade Debug] ${Date.now()}: Attempted to cancel non-existent trade offer ID: ${offerId}.`);
            }
        }

        /**
         * Displays the details of a trade offer in a view-only modal, with conditional action buttons.
         * @param {string} offerId - The ID of the trade offer to display.
         */
        function displayTradeDetailsView(offerId) {
            const offer = gameState.pendingTradeOffers.find(o => o.offerId === offerId);
            if (!offer) {
                alert(getTranslation("tradeNotFound"));
                console.warn(`[Trade Debug] ${Date.now()}: Trade offer not found for details view: ${offerId}.`);
                return;
            }

            const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
            const tradeDetailsSenderName = document.getElementById('tradeDetailsSenderName');
            const tradeDetailsRecipientName = document.getElementById('tradeDetailsRecipientName');
            const tradeDetailsOfferedMoney = document.getElementById('tradeDetailsOfferedMoney');
            const tradeDetailsOfferedProperties = document.getElementById('tradeDetailsOfferedProperties');
            const tradeDetailsRequestedMoney = document.getElementById('tradeDetailsRequestedMoney');
            const tradeDetailsRequestedProperties = document.getElementById('tradeDetailsRequestedProperties');
            const tradeDetailsActionButtons = document.getElementById('tradeDetailsActionButtons');

            if (!tradeDetailsViewModal || !tradeDetailsSenderName || !tradeDetailsRecipientName || !tradeDetailsOfferedMoney || !tradeDetailsOfferedProperties || !tradeDetailsRequestedMoney || !tradeDetailsRequestedProperties || !tradeDetailsActionButtons) return;

            const sender = gameState.players.find(p => p.id === offer.senderId);
            const recipient = gameState.players.find(p => p.id === offer.recipientId);
            const currentPlayer = gameState.currentUser;

            // Display only names in the details view, without flags
            tradeDetailsSenderName.textContent = sender ? sender.name : 'Unknown';
            tradeDetailsRecipientName.textContent = recipient ? recipient.name : 'Unknown';
            tradeDetailsOfferedMoney.textContent = offer.offeredMoney;
            tradeDetailsRequestedMoney.textContent = offer.requestedMoney;

            // Populate offered properties with flags/emojis
            tradeDetailsOfferedProperties.innerHTML = '';
            if (offer.offeredProperties.length > 0) {
                offer.offeredProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        tradeDetailsOfferedProperties.appendChild(listItem);
                    }
                });
            } else {
                tradeDetailsOfferedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            // Populate requested properties with flags/emojis
            tradeDetailsRequestedProperties.innerHTML = '';
            if (offer.requestedProperties.length > 0) {
                offer.requestedProperties.forEach(propId => {
                    const prop = gameState.boardCellsInfo.find(cell => cell.id === propId);
                    if (prop) {
                        const listItem = document.createElement('li');
                        listItem.classList.add('flex', 'items-center', 'gap-1'); // Added flex for horizontal alignment
                        let iconHtml = '';
                        let propertyDisplayName = prop.content[gameState.currentLanguage] || prop.content['en'] || prop.content;
                        if (prop.type === 'city') {
                            iconHtml = `${getCountryFlagImage(prop.country[gameState.currentLanguage] || prop.country['en'])}`;
                        } else if (prop.type === 'company') {
                            iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                        }
                        listItem.innerHTML = `${iconHtml} <span>${propertyDisplayName}</span>`; // Wrapped text in span
                        tradeDetailsRequestedProperties.appendChild(listItem);
                    }
                });
            } else {
                tradeDetailsRequestedProperties.innerHTML = `<li>${getTranslation('none')}</li>`;
            }

            // Clear and add action buttons based on current player's role
            tradeDetailsActionButtons.innerHTML = '';
            gameState.currentActiveTradeOffer = offer; // Set the active offer for accept/decline logic

            if (currentPlayer && currentPlayer.id === offer.recipientId) {
                // Recipient actions
                const acceptBtn = document.createElement('button');
                acceptBtn.className = 'btn-primary py-2 px-6 rounded-md';
                acceptBtn.textContent = getTranslation('accept');
                acceptBtn.onclick = acceptTrade;
                tradeDetailsActionButtons.appendChild(acceptBtn);

                const declineBtn = document.createElement('button');
                declineBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                declineBtn.textContent = getTranslation('decline');
                declineBtn.onclick = declineTrade;
                tradeDetailsActionButtons.appendChild(declineBtn);

                const modifyBtn = document.createElement('button');
                modifyBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                modifyBtn.textContent = getTranslation('modify');
                modifyBtn.onclick = () => {
                    const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
                    if (tradeDetailsViewModal) tradeDetailsViewModal.classList.add('hidden');
                    // When recipient modifies, it's a counter-offer from recipient to sender
                    openTradeCreationModal(currentPlayer.id, {
                        offerId: offer.offerId, // Keep original offerId for tracking purposes if needed, or generate new
                        senderId: currentPlayer.id,
                        recipientId: offer.senderId,
                        offeredMoney: offer.requestedMoney, // What recipient was asked for, they now offer
                        offeredProperties: offer.requestedProperties, // What recipient was asked for, they now offer
                        requestedMoney: offer.offeredMoney, // What sender offered, recipient now requests
                        requestedProperties: offer.offeredProperties, // What sender offered, recipient now requests
                    });
                };
                tradeDetailsActionButtons.appendChild(modifyBtn);

            } else if (currentPlayer && currentPlayer.id === offer.senderId) {
                // Sender actions
                const modifyBtn = document.createElement('button');
                modifyBtn.className = 'btn-secondary py-2 px-6 rounded-md';
                modifyBtn.textContent = getTranslation('modify');
                modifyBtn.onclick = () => {
                    const tradeDetailsViewModal = document.getElementById('tradeDetailsViewModal');
                    if (tradeDetailsViewModal) tradeDetailsViewModal.classList.add('hidden');
                    openTradeCreationModal(currentPlayer.id, offer); // Pass the existing offer to pre-fill
                };
                tradeDetailsActionButtons.appendChild(modifyBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn-secondary py-2 px-6 rounded-md bg-red-600 hover:bg-red-700';
                cancelBtn.textContent = getTranslation('cancel');
                cancelBtn.onclick = () => cancelTrade(offer.offerId);
                tradeDetailsActionButtons.appendChild(cancelBtn);
            }

            tradeDetailsViewModal.classList.remove('hidden');
            console.log(`[Trade Debug] ${Date.now()}: Trade details view modal displayed for offer ID: ${offerId}. Current player role: ${currentPlayer?.id === offer.recipientId ? 'Recipient' : currentPlayer?.id === offer.senderId ? 'Sender' : 'Viewer'}.`);
        }

        /**
         * Updates the list of pending trade offers displayed in the sidebar.
         */
        function updatePendingTradesList() {
            const pendingTradesListElem = document.getElementById('pendingTradesList');
            const pendingTradesCountElem = document.getElementById('pendingTradesCount');
            if (!pendingTradesListElem || !pendingTradesCountElem) return;

            pendingTradesListElem.innerHTML = ''; // Clear current list

            // Filter out trades involving players who are no longer in the game (local only, so just check if player exists in gameState.players)
            gameState.pendingTradeOffers = gameState.pendingTradeOffers.filter(offer =>
                gameState.players.some(p => p.id === offer.senderId) &&
                gameState.players.some(p => p.id === offer.recipientId)
            );

            pendingTradesCountElem.textContent = gameState.pendingTradeOffers.length;
            console.log(`[Trade Debug] ${Date.now()}: Updating pending trades list. Count: ${gameState.pendingTradeOffers.length}.`);

            if (gameState.pendingTradeOffers.length === 0) {
                const noTradesMessage = document.createElement('p');
                noTradesMessage.classList.add('text-gray-400');
                noTradesMessage.textContent = getTranslation('noPendingTrades');
                pendingTradesListElem.appendChild(noTradesMessage);
            } else {
                gameState.pendingTradeOffers.forEach(offer => {
                    const sender = gameState.players.find(p => p.id === offer.senderId);
                    const recipient = gameState.players.find(p => p.id === offer.recipientId);

                    const senderName = sender ? sender.name : 'Unknown';
                    const recipientName = recipient ? recipient.name : 'Unknown';

                    const tradeItem = document.createElement('div');
                    tradeItem.classList.add('pending-trade-item');
                    tradeItem.innerHTML = `
                        <span class="trade-summary">${senderName} ↔ ${recipientName}</span>
                        <span class="trade-details">${getTranslation('offer')}: $${offer.offeredMoney} + ${offer.offeredProperties.length} ${getTranslation(offer.offeredProperties.length === 1 ? 'prop' : 'props')}</span>
                        <span class="trade-details">${getTranslation('request')}: $${offer.requestedMoney} + ${offer.requestedProperties.length} ${getTranslation(offer.requestedProperties.length === 1 ? 'prop' : 'props')}</span>
                    `;
                    tradeItem.onclick = () => displayTradeDetailsView(offer.offerId);
                    pendingTradesListElem.appendChild(tradeItem);
                });
            }
        }

        /**
         * Opens the sell property modal, populating it with the current player's properties.
         */
        function openSellPropertyModal() {
            const sellPropertyModal = document.getElementById('sellPropertyModal');
            const propertiesToSellList = document.getElementById('propertiesToSellList');
            const confirmSellPropertiesBtn = document.getElementById('confirmSellPropertiesBtn');
            if (!sellPropertyModal || !propertiesToSellList || !confirmSellPropertiesBtn) return;

            const currentPlayer = gameState.currentUser;

            if (!currentPlayer) {
                alert(getTranslation('notLoggedIn'));
                return;
            }

            propertiesToSellList.innerHTML = ''; // Clear current list

            const playerProperties = Object.values(gameState.boardProperties).filter(
                prop => prop.ownerId === currentPlayer.id
            );
            console.log(`[Sell Property Debug] ${Date.now()}: Opening sell property modal for ${currentPlayer.name}. Properties owned: ${playerProperties.length}.`);

            if (playerProperties.length === 0) {
                const p = document.createElement('p');
                p.classList.add('text-gray-400');
                p.textContent = getTranslation('noPropertiesToSell');
                propertiesToSellList.appendChild(p);
                confirmSellPropertiesBtn.disabled = true;
            } else {
                confirmSellPropertiesBtn.disabled = false;
                playerProperties.forEach(prop => {
                    const originalCell = gameState.boardCellsInfo.find(cell => cell.id === prop.id);
                    const sellPrice = roundToNearestFive(originalCell.price / 2); // Sell for half the original price

                    const listItem = document.createElement('div');
                    listItem.className = 'flex items-center gap-2 py-1';
                    let iconHtml = '';
                    let propertyDisplayName = originalCell.content[gameState.currentLanguage] || originalCell.content['en'] || originalCell.content;
                    if (originalCell && originalCell.type === 'city') {
                        iconHtml = `${getCountryFlagImage(originalCell.country[gameState.currentLanguage] || originalCell.country['en'])}`;
                    } else if (originalCell && originalCell.type === 'company') {
                        iconHtml = `<span class="text-lg">${getCompanyEmoji(propertyDisplayName)}</span>`;
                    }
                    listItem.innerHTML = `
                        <input type="checkbox" id="sell-prop-${prop.id}" value="${prop.id}" data-sell-price="${sellPrice}" class="form-checkbox h-4 w-4 text-purple-600">
                        <label for="sell-prop-${prop.id}" class="text-gray-300 text-sm flex items-center gap-1">
                            ${iconHtml} <span>${propertyDisplayName} ($${sellPrice})</span>
                        </label>
                    `;
                    propertiesToSellList.appendChild(listItem);
                });
            }
            sellPropertyModal.classList.remove('hidden');
        }

        /**
         * Handles the selling of selected properties.
         */
        function sellSelectedProperties() {
            const propertiesToSellCheckboxes = document.querySelectorAll('#propertiesToSellList input[type="checkbox"]:checked');
            const currentPlayer = gameState.currentUser;
            let totalRefund = 0;
            const soldPropertyIds = [];

            if (!currentPlayer) {
                alert(getTranslation('notLoggedIn'));
                return;
            }

            if (propertiesToSellCheckboxes.length === 0) {
                alert(getTranslation("selectAtLeastOne"));
                console.warn(`[Sell Property Debug] ${Date.now()}: No properties selected for selling.`);
                return;
            }

            propertiesToSellCheckboxes.forEach(checkbox => {
                const propId = checkbox.value;
                const sellPrice = parseInt(checkbox.dataset.sellPrice);

                totalRefund += sellPrice;
                soldPropertyIds.push(propId);

                // Update the property in gameState.boardCellsInfo and gameState.boardProperties
                const propertyInCellsInfo = gameState.boardCellsInfo.find(cell => cell.id === propId);
                if (propertyInCellsInfo) {
                    propertyInCellsInfo.owner = null; // No owner
                    propertyInCellsInfo.currentUpgradeLevel = 0; // Reset level
                    const cellElement = document.querySelector(`.${propId}`);
                    if (cellElement) updateBoardCellDisplay(cellElement, propertyInCellsInfo);
                }
                delete gameState.boardProperties[propId]; // Remove from owned properties map
                console.log(`[Sell Property Debug] ${Date.now()}: Property ${propertyInCellsInfo?.content[gameState.currentLanguage] || propertyInCellsInfo?.content['en']} (ID: ${propId}) sold for $${sellPrice}.`);
            });

            currentPlayer.money += totalRefund;
            updatePlayersList();
            updateMyPropertiesList();
            const sellPropertyModal = document.getElementById('sellPropertyModal');
            if (sellPropertyModal) sellPropertyModal.classList.add('hidden');
            alert(getTranslation('playerSold', currentPlayer.name, soldPropertyIds.length, totalRefund, currentPlayer.money));
            showMoneyEffect(currentPlayer.id, totalRefund, 'gain');
            checkPlayerDebtStatus(); // Check debt status after selling properties
            console.log(`[Sell Property Debug] ${Date.now()}: Player ${currentPlayer.name} completed selling properties. Total refund: $${totalRefund}. New money: ${currentPlayer.money}.`);
        }

        /**
         * Kicks a player from the lobby by the leader.
         * @param {string} playerIdToKick - The ID of the player to be kicked.
         */
        function kickPlayerFromLobby(playerIdToKick) {
            const leaderPlayer = gameState.currentUser; // Leader is the current logged-in user
            if (!leaderPlayer || leaderPlayer.id !== gameState.leaderId) {
                alert(getTranslation('onlyLeaderCanKick'));
                console.warn(`[Lobby Kick Debug] ${Date.now()}: Kick attempt failed. Current user is not the leader.`);
                return;
            }

            const playerIndexToKick = gameState.players.findIndex(p => p.id === playerIdToKick);
            if (playerIndexToKick === -1) {
                console.warn(`[Lobby Kick Debug] ${Date.now()}: Attempted to kick non-existent player ID: ${playerIdToKick}.`);
                return;
            }

            const kickedPlayer = gameState.players[playerIndexToKick];

            // Confirmation dialog (using custom alert)
            alert(getTranslation('confirmKick', kickedPlayer.name));
            const customAlert = document.getElementById('custom-alert');
            if (!customAlert) return;

            const okButton = customAlert.querySelector('button');

            // Replace OK button with Confirm/Cancel for kick
            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Confirm'; // Not translated, as it's a temporary dialog
            confirmButton.className = 'bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 mr-2';
            confirmButton.onclick = () => {
                gameState.players.splice(playerIndexToKick, 1);
                if (kickedPlayer.id === gameState.leaderId && gameState.players.length > 0) {
                    gameState.leaderId = gameState.players[0].id; // Assign new leader
                } else if (gameState.players.length === 0) {
                    gameState.leaderId = null;
                }
                updateLobbyPlayerCards();
                const customAlert = document.getElementById('custom-alert');
                if (customAlert) customAlert.remove();
                alert(getTranslation('playerKicked', kickedPlayer.name));
                console.log(`[Lobby Kick Debug] ${Date.now()}: Player ${kickedPlayer.name} (ID: ${kickedPlayer.id}) kicked from lobby.`);

                // Disable play button if not enough players left
                const lobbyPlayButton = document.getElementById('lobbyPlayButton');
                if (lobbyPlayButton) {
                    lobbyPlayButton.disabled = gameState.players.length !== MIN_PLAYERS_PER_GAME;
                }
            };

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel'; // Not translated
            cancelButton.className = 'bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500';
            cancelButton.onclick = () => {
                const customAlert = document.getElementById('custom-alert');
                if (customAlert) customAlert.remove();
                console.log(`[Lobby Kick Debug] ${Date.now()}: Kick action cancelled for player ID: ${playerIdToKick}.`);
            };

            if (okButton) okButton.replaceWith(confirmButton, cancelButton);
        }

        /**
         * Dynamically updates the player cards shown in the lobby.
         * This function will create a player card for each player in gameState.players.
         */
        function updateLobbyPlayerCards() {
            const lobbyPlayerCardsContainer = document.getElementById('lobbyPlayerCardsContainer');
            if (!lobbyPlayerCardsContainer) return;

            lobbyPlayerCardsContainer.innerHTML = ''; // Clear existing cards

            // Render existing players
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';

                let crownHtml = '';
                if (player.id === gameState.leaderId) {
                    crownHtml = `<i class="fas fa-crown leader-crown"></i>`;
                }

                let kickButtonHtml = '';
                // Only show kick button if current user is leader and it's not their own card
                if (gameState.currentUser && gameState.leaderId !== null && gameState.currentUser.id === gameState.leaderId && player.id !== gameState.currentUser.id) {
                    kickButtonHtml = `<button class="kick-button" onclick="kickPlayerFromLobby('${player.id}')">${getTranslation('kick')}</button>`;
                }

                playerCard.innerHTML = `
                    ${crownHtml}
                    <div class="player-icon" style="color: ${player.color};"><i class="fas fa-user-circle"></i></div>
                    <h4 class="text-lg font-bold text-white">${player.name}</h4>
                    <p class="text-gray-400">${getTranslation('money')}: <span class="text-green-400 font-bold">$${player.money}</span></p>
                    <span class="status-badge">${getTranslation('ready')}</span>
                    ${kickButtonHtml}
                `;
                lobbyPlayerCardsContainer.appendChild(playerCard);
            });

            // Update the lobby player count display
            const lobbyPlayerCount = document.getElementById('lobbyPlayerCount');
            if (lobbyPlayerCount) lobbyPlayerCount.textContent = `${gameState.players.length}/${MAX_PLAYERS_PER_GAME}`;

            const lobbyPlayerMoney = document.getElementById('lobbyPlayerMoney');
            if (lobbyPlayerMoney) lobbyPlayerMoney.textContent = gameState.currentUser ? gameState.currentUser.money : '0';
            console.log(`[Lobby Debug] ${Date.now()}: Lobby player cards updated. Current count: ${gameState.players.length}/${MAX_PLAYERS_PER_GAME}.`);
        }

        // --- Settings Modal Functions ---
        function openSettingsModal() {
            const settingsModal = document.getElementById('settingsModal');
            const languageSelect = document.getElementById('languageSelect');
            if (!settingsModal || !languageSelect) return;

            languageSelect.value = gameState.currentLanguage; // Set dropdown to current language
            settingsModal.classList.remove('hidden');
            console.log(`[Settings Debug] ${Date.now()}: Settings modal opened. Current language: ${gameState.currentLanguage}.`);
        }

        function applySettings() {
            const languageSelect = document.getElementById('languageSelect');
            if (!languageSelect) return;

            const selectedLanguage = languageSelect.value;
            if (gameState.currentLanguage !== selectedLanguage) {
                gameState.currentLanguage = selectedLanguage;
                updateAllTextContent(); // Re-render all text content with new language
                // Re-populate board to apply new language for city names etc.
                // This ensures the board content is updated without changing layout.
                populateBoard();
                addPlayerTokens(); // Re-add tokens to ensure they are on the correct cells after repopulating
                updatePlayersList();
                updateMyPropertiesList();
                updatePendingTradesList();
                // No change to document.body.dir here, as requested by the user.
                console.log(`[Settings Debug] ${Date.now()}: Language set to: ${selectedLanguage}.`);
            }
            closeSettingsModal();
        }

        function closeSettingsModal() {
            const settingsModal = document.getElementById('settingsModal');
            if (settingsModal) settingsModal.classList.add('hidden');
            console.log(`[Settings Debug] ${Date.now()}: Settings modal closed.`);
        }

        // --- Local Game Management ---
        function startLocalGame() {
            // Initialize current user as a guest if not already
            if (!gameState.currentUser) {
                const guestId = `guest-${Math.random().toString(36).substring(2, 9)}`;
                const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500'];
                const assignedColor = playerColors[Math.floor(Math.random() * playerColors.length)];
                gameState.currentUser = {
                    id: guestId,
                    name: getTranslation('guestUser'),
                    money: gameState.STARTING_MONEY,
                    color: assignedColor,
                    positionIndex: 0,
                    isReady: true
                };
            }

            // Clear previous game state if any
            gameState.players = [];
            gameState.boardProperties = {};
            gameState.pendingTradeOffers = [];

            // Add the current user
            gameState.players.push(gameState.currentUser);

            // Add AI players to reach MIN_PLAYERS_PER_GAME (which is also MAX_PLAYERS_PER_GAME)
            for (let i = gameState.players.length; i < MAX_PLAYERS_PER_GAME; i++) {
                const aiId = `ai-${i}-${Math.random().toString(36).substring(2, 5)}`;
                const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500'];
                // Assign a color that hasn't been used yet if possible, or cycle through
                const assignedColor = playerColors[i % playerColors.length];
                gameState.players.push({
                    id: aiId,
                    name: getTranslation('aiPlayer', i),
                    money: gameState.STARTING_MONEY,
                    color: assignedColor,
                    positionIndex: 0,
                    isReady: true
                });
            }

            // Randomly select the first player
            gameState.currentPlayerIndex = Math.floor(Math.random() * gameState.players.length);
            gameState.leaderId = gameState.players[0].id; // First player added is still the leader for lobby purposes

            console.log(`[Local Game] Starting new local game. Players:`, gameState.players);
            console.log(`[Local Game] First player to start: ${gameState.players[gameState.currentPlayerIndex].name}`);


            const lobbyPage = document.getElementById('lobbyPage');
            if (lobbyPage) lobbyPage.classList.add('hidden');
            const gamePage = document.getElementById('gamePage');
            if (gamePage) gamePage.classList.remove('hidden');
            const lobbyPlayButton = document.getElementById('lobbyPlayButton');
            if (lobbyPlayButton) lobbyPlayButton.disabled = false;
            const lobbyMessage = document.getElementById('lobbyMessage');
            if (lobbyMessage) lobbyMessage.classList.add('hidden');

            // Set up game board and players
            populateBoard();
            addPlayerTokens();
            updatePlayersList();
            updateMyPropertiesList();
            updatePendingTradesList(); // Clear any old pending trades
            startTurnTimer(); // Start timer for the first player
            updateAllTextContent(); // Update all text content
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Initializing local game.");

            // Initialize current user as a guest immediately
            const guestId = `guest-${Math.random().toString(36).substring(2, 9)}`;
            const playerColors = ['#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF4500'];
            const assignedColor = playerColors[Math.floor(Math.random() * playerColors.length)];
            gameState.currentUser = {
                id: guestId,
                name: getTranslation('guestUser'),
                money: gameState.STARTING_MONEY,
                color: assignedColor,
                positionIndex: 0,
                isReady: true
            };
            const lobbyPlayerMoney = document.getElementById('lobbyPlayerMoney');
            if (lobbyPlayerMoney) lobbyPlayerMoney.textContent = gameState.currentUser.money;
            const currentUserIdDisplay = document.getElementById('currentUserIdDisplay');
            if (currentUserIdDisplay) currentUserIdDisplay.textContent = gameState.currentUser.name;

            // Populate board initially (even before game starts, for data structure)
            populateBoard();

            // Lobby Page Event Listeners
            const lobbyPlayButton = document.getElementById('lobbyPlayButton');
            if (lobbyPlayButton) lobbyPlayButton.addEventListener('click', startLocalGame);

            // Game Modes Navigation (for UI only in local game)
            const unratedMode = document.getElementById('unratedMode');
            if (unratedMode) unratedMode.addEventListener('click', () => {
                document.querySelectorAll('.game-modes-nav a').forEach(link => link.classList.remove('active'));
                unratedMode.classList.add('active');
                console.log('Unrated Mode Selected');
            });
            const competitiveMode = document.getElementById('competitiveMode');
            if (competitiveMode) competitiveMode.addEventListener('click', () => {
                document.querySelectorAll('.game-modes-nav a').forEach(link => link.classList.remove('active'));
                competitiveMode.classList.add('active');
                console.log('Competitive Mode Selected');
            });
            const customMode = document.getElementById('customMode');
            if (customMode) customMode.addEventListener('click', () => {
                document.querySelectorAll('.game-modes-nav a').forEach(link => link.classList.remove('active'));
                customMode.classList.add('active');
                console.log('Custom Mode Selected');
            });


            // Settings button
            const settingsBtn = document.getElementById('settingsBtn');
            if (settingsBtn) settingsBtn.addEventListener('click', openSettingsModal);
            const applySettingsBtn = document.getElementById('applySettingsBtn');
            if (applySettingsBtn) applySettingsBtn.addEventListener('click', applySettings);
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', closeSettingsModal);

            // Chat input listener
            const chatSendBtn = document.getElementById('chatSendBtn');
            const chatInput = document.getElementById('chatInput');
            if (chatSendBtn && chatInput) {
                chatSendBtn.addEventListener('click', () => {
                    const message = chatInput.value.trim();
                    if (message) {
                        gameState.chatMessages.push({ sender: gameState.currentUser.name, message: message });
                        renderChatMessages();
                        chatInput.value = '';
                    }
                });
                chatInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        chatSendBtn.click();
                    }
                });
            }


            // Function to render chat messages
            function renderChatMessages() {
                const chatMessagesDiv = document.getElementById('chatMessages');
                if (!chatMessagesDiv) return;

                chatMessagesDiv.innerHTML = ''; // Clear existing messages
                gameState.chatMessages.forEach(chatMsg => {
                    const msgElement = document.createElement('p');
                    msgElement.classList.add('mb-1');
                    msgElement.innerHTML = `<span class="font-bold text-blue-400">${chatMsg.sender}:</span> ${chatMsg.message}`;
                    chatMessagesDiv.appendChild(msgElement);
                });
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Scroll to bottom
            }
            renderChatMessages(); // Initial render for chat

            // Trade System Event Listeners
            const sendTradeOfferBtn = document.getElementById('sendTradeOfferBtn');
            if (sendTradeOfferBtn) sendTradeOfferBtn.addEventListener('click', sendTradeOffer);
            const acceptTradeBtn = document.getElementById('acceptTradeBtn');
            if (acceptTradeBtn) acceptTradeBtn.addEventListener('click', acceptTrade);
            const declineTradeBtn = document.getElementById('declineTradeBtn');
            if (declineTradeBtn) declineTradeBtn.addEventListener('click', declineTrade);
            const confirmSellPropertiesBtn = document.getElementById('confirmSellPropertiesBtn');
            if (confirmSellPropertiesBtn) confirmSellPropertiesBtn.addEventListener('click', sellSelectedProperties);

            // Initial text content update
            updateAllTextContent();
        });

        // Expose functions to global scope for inline HTML event handlers (e.g., onclick)
        window.openTradeCreationModal = openTradeCreationModal;
        window.kickPlayerFromLobby = kickPlayerFromLobby;
        window.displayPropertyDetails = displayPropertyDetails;
        window.openSellPropertyModal = openSellPropertyModal;
        window.displayTradeDetailsView = displayTradeDetailsView; // Expose for pending trades list items
    </script>
</body>
</html>
